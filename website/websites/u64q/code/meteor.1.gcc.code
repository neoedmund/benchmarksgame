<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com"> * http://benchmarksgame.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * contributed by Christian Vosteen</span>
<span class="com"> */</span>

<span class="ppc">#include &lt;stdlib.h&gt;</span>
<span class="ppc">#include &lt;stdio.h&gt;</span>
<span class="ppc">#define TRUE 1</span>
<span class="ppc">#define FALSE 0</span>

<span class="com">/* The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="com"> * maximum speed the board will be implemented as     . . . . .</span>
<span class="com"> * 50 bits, which will fit into a 64 bit long long   . . . . .</span>
<span class="com"> * int.                                               . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> * I will represent 0's as empty cells and 1's        . . . . .</span>
<span class="com"> * as full cells.                                    . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> */</span>

<span class="kwb">unsigned long long</span> board = <span class="num">0xFFFC000000000000</span>ULL;

<span class="com">/* The puzzle pieces must be specified by the path followed</span>
<span class="com"> * from one end to the other along 12 hexagonal directions.</span>
<span class="com"> *</span>
<span class="com"> *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="com"> *                   </span>
<span class="com"> *  O O O O    O   O O   O O O     O O O     O   O</span>
<span class="com"> *         O    O O           O       O       O O</span>
<span class="com"> *                           O         O         O</span>
<span class="com"> *</span>
<span class="com"> *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="com"> *</span>
<span class="com"> *    O O O     O O       O O     O O        O O O O</span>
<span class="com"> *       O O       O O       O       O O O        O</span>
<span class="com"> *                  O       O O</span>
<span class="com"> *</span>
<span class="com"> * I had to make it 12 directions because I wanted all of the</span>
<span class="com"> * piece definitions to fit into the same size arrays.  It is</span>
<span class="com"> * not possible to define piece 4 in terms of the 6 cardinal</span>
<span class="com"> * directions in 4 moves.</span>
<span class="com"> */</span>

<span class="ppc">#define E     0</span>
<span class="ppc">#define ESE   1</span>
<span class="ppc">#define SE    2</span>
<span class="ppc">#define S     3</span>
<span class="ppc">#define SW    4</span>
<span class="ppc">#define WSW   5</span>
<span class="ppc">#define W     6</span>
<span class="ppc">#define WNW   7</span>
<span class="ppc">#define NW    8</span>
<span class="ppc">#define N     9</span>
<span class="ppc">#define NE    10</span>
<span class="ppc">#define ENE   11</span>
<span class="ppc">#define PIVOT 12</span>

<span class="kwb">char</span> piece_def[<span class="num">10</span>][<span class="num">4</span>] = {
   {  E,  E,  E, SE},
   { SE,  E, NE,  E},
   {  E,  E, SE, SW},
   {  E,  E, SW, SE},
   { SE,  E, NE,  S},
   {  E,  E, SW,  E},
   {  E, SE, SE, NE},
   {  E, SE, SE,  W},
   {  E, SE,  E,  E},
   {  E,  E,  E, SW}
};

 
<span class="com">/* To minimize the amount of work done in the recursive solve function below,</span>
<span class="com"> * I'm going to allocate enough space for all legal rotations of each piece</span>
<span class="com"> * at each position on the board. That's 10 pieces x 50 board positions x</span>
<span class="com"> * 12 rotations.  However, not all 12 rotations will fit on every cell, so</span>
<span class="com"> * I'll have to keep count of the actual number that do.</span>
<span class="com"> * The pieces are going to be unsigned long long ints just like the board so</span>
<span class="com"> * they can be bitwise-anded with the board to determine if they fit.</span>
<span class="com"> * I'm also going to record the next possible open cell for each piece and</span>
<span class="com"> * location to reduce the burden on the solve function.</span>
<span class="com"> */</span>
<span class="kwb">unsigned long long</span> pieces[<span class="num">10</span>][<span class="num">50</span>][<span class="num">12</span>];
<span class="kwb">int</span> piece_counts[<span class="num">10</span>][<span class="num">50</span>];
<span class="kwb">char</span> next_cell[<span class="num">10</span>][<span class="num">50</span>][<span class="num">12</span>];

<span class="com">/* Returns the direction rotated 60 degrees clockwise */</span>
<span class="kwb">char</span> <span class="kwd">rotate</span>(<span class="kwb">char</span> dir) {
   <span class="kwa">return</span> (dir + <span class="num">2</span>) % PIVOT;
}

<span class="com">/* Returns the direction flipped on the horizontal axis */</span>
<span class="kwb">char</span> <span class="kwd">flip</span>(<span class="kwb">char</span> dir) {
   <span class="kwa">return</span> (PIVOT - dir) % PIVOT;
}


<span class="com">/* Returns the new cell index from the specified cell in the</span>
<span class="com"> * specified direction.  The index is only valid if the</span>
<span class="com"> * starting cell and direction have been checked by the</span>
<span class="com"> * out_of_bounds function first.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">shift</span>(<span class="kwb">char</span> cell, <span class="kwb">char</span> dir) {
   <span class="kwa">switch</span>(dir) {
      <span class="kwa">case</span> E:
         <span class="kwa">return</span> cell + <span class="num">1</span>;
      <span class="kwa">case</span> ESE:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell + <span class="num">7</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell + <span class="num">6</span>;
      <span class="kwa">case</span> SE:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell + <span class="num">6</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell + <span class="num">5</span>;
      <span class="kwa">case</span> S:
         <span class="kwa">return</span> cell + <span class="num">10</span>;
      <span class="kwa">case</span> SW:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell + <span class="num">5</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell + <span class="num">4</span>;
      <span class="kwa">case</span> WSW:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell + <span class="num">4</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell + <span class="num">3</span>;
      <span class="kwa">case</span> W:
         <span class="kwa">return</span> cell - <span class="num">1</span>;
      <span class="kwa">case</span> WNW:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell - <span class="num">6</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell - <span class="num">7</span>;
      <span class="kwa">case</span> NW:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell - <span class="num">5</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell - <span class="num">6</span>;
      <span class="kwa">case</span> N:
         <span class="kwa">return</span> cell - <span class="num">10</span>;
      <span class="kwa">case</span> NE:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell - <span class="num">4</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell - <span class="num">5</span>;
      <span class="kwa">case</span> ENE:
         <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
            <span class="kwa">return</span> cell - <span class="num">3</span>;
         <span class="kwa">else</span>
            <span class="kwa">return</span> cell - <span class="num">4</span>;
      <span class="kwa">default</span>:
         <span class="kwa">return</span> cell;
   }
}

<span class="com">/* Returns wether the specified cell and direction will land outside</span>
<span class="com"> * of the board.  Used to determine if a piece is at a legal board</span>
<span class="com"> * location or not.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">out_of_bounds</span>(<span class="kwb">char</span> cell, <span class="kwb">char</span> dir) {
   <span class="kwb">char</span> i;
   <span class="kwa">switch</span>(dir) {
      <span class="kwa">case</span> E:
         <span class="kwa">return</span> cell % <span class="num">5</span> == <span class="num">4</span>;
      <span class="kwa">case</span> ESE:
         i = cell % <span class="num">10</span>;   
         <span class="kwa">return</span> i == <span class="num">4</span> || i == <span class="num">8</span> || i == <span class="num">9</span> || cell &gt;= <span class="num">45</span>;
      <span class="kwa">case</span> SE:
         <span class="kwa">return</span> cell % <span class="num">10</span> == <span class="num">9</span> || cell &gt;= <span class="num">45</span>;
      <span class="kwa">case</span> S:
         <span class="kwa">return</span> cell &gt;= <span class="num">40</span>;
      <span class="kwa">case</span> SW:
         <span class="kwa">return</span> cell % <span class="num">10</span> == <span class="num">0</span> || cell &gt;= <span class="num">45</span>;
      <span class="kwa">case</span> WSW:
         i = cell % <span class="num">10</span>;   
         <span class="kwa">return</span> i == <span class="num">0</span> || i == <span class="num">1</span> || i == <span class="num">5</span> || cell &gt;= <span class="num">45</span>;
      <span class="kwa">case</span> W:
         <span class="kwa">return</span> cell % <span class="num">5</span> == <span class="num">0</span>;
      <span class="kwa">case</span> WNW:
         i = cell % <span class="num">10</span>;   
         <span class="kwa">return</span> i == <span class="num">0</span> || i == <span class="num">1</span> || i == <span class="num">5</span> || cell &lt; <span class="num">5</span>;
      <span class="kwa">case</span> NW:
         <span class="kwa">return</span> cell % <span class="num">10</span> == <span class="num">0</span> || cell &lt; <span class="num">5</span>;
      <span class="kwa">case</span> N:
         <span class="kwa">return</span> cell &lt; <span class="num">10</span>;
      <span class="kwa">case</span> NE:
         <span class="kwa">return</span> cell % <span class="num">10</span> == <span class="num">9</span> || cell &lt; <span class="num">5</span>;
      <span class="kwa">case</span> ENE:
         i = cell % <span class="num">10</span>;   
         <span class="kwa">return</span> i == <span class="num">4</span> || i == <span class="num">8</span> || i == <span class="num">9</span> || cell &lt; <span class="num">5</span>;
      <span class="kwa">default</span>:
         <span class="kwa">return</span> FALSE;
   }
}

<span class="com">/* Rotate a piece 60 degrees clockwise */</span>
<span class="kwb">void</span> <span class="kwd">rotate_piece</span>(<span class="kwb">int</span> piece) {
   <span class="kwb">int</span> i;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">4</span>; i++)
      piece_def[piece][i] = <span class="kwd">rotate</span>(piece_def[piece][i]);
}

<span class="com">/* Flip a piece along the horizontal axis */</span>
<span class="kwb">void</span> <span class="kwd">flip_piece</span>(<span class="kwb">int</span> piece) {
   <span class="kwb">int</span> i;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">4</span>; i++)
      piece_def[piece][i] = <span class="kwd">flip</span>(piece_def[piece][i]);
}

<span class="com">/* Convenience function to quickly calculate all of the indices for a piece */</span>
<span class="kwb">void</span> <span class="kwd">calc_cell_indices</span>(<span class="kwb">char</span> *cell, <span class="kwb">int</span> piece, <span class="kwb">char</span> index) {
   cell[<span class="num">0</span>] = index;
   cell[<span class="num">1</span>] = <span class="kwd">shift</span>(cell[<span class="num">0</span>], piece_def[piece][<span class="num">0</span>]);
   cell[<span class="num">2</span>] = <span class="kwd">shift</span>(cell[<span class="num">1</span>], piece_def[piece][<span class="num">1</span>]);
   cell[<span class="num">3</span>] = <span class="kwd">shift</span>(cell[<span class="num">2</span>], piece_def[piece][<span class="num">2</span>]);
   cell[<span class="num">4</span>] = <span class="kwd">shift</span>(cell[<span class="num">3</span>], piece_def[piece][<span class="num">3</span>]);
}

<span class="com">/* Convenience function to quickly calculate if a piece fits on the board */</span>
<span class="kwb">int</span> <span class="kwd">cells_fit_on_board</span>(<span class="kwb">char</span> *cell, <span class="kwb">int</span> piece) {
   <span class="kwa">return</span> (!<span class="kwd">out_of_bounds</span>(cell[<span class="num">0</span>], piece_def[piece][<span class="num">0</span>]) &amp;&amp;
         !<span class="kwd">out_of_bounds</span>(cell[<span class="num">1</span>], piece_def[piece][<span class="num">1</span>]) &amp;&amp; 
         !<span class="kwd">out_of_bounds</span>(cell[<span class="num">2</span>], piece_def[piece][<span class="num">2</span>]) &amp;&amp; 
         !<span class="kwd">out_of_bounds</span>(cell[<span class="num">3</span>], piece_def[piece][<span class="num">3</span>]));
}

<span class="com">/* Returns the lowest index of the cells of a piece.</span>
<span class="com"> * I use the lowest index that a piece occupies as the index for looking up</span>
<span class="com"> * the piece in the solve function.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">minimum_of_cells</span>(<span class="kwb">char</span> *cell) {
   <span class="kwb">char</span> minimum = cell[<span class="num">0</span>];
   minimum = cell[<span class="num">1</span>] &lt; minimum ? cell[<span class="num">1</span>] : minimum;
   minimum = cell[<span class="num">2</span>] &lt; minimum ? cell[<span class="num">2</span>] : minimum;
   minimum = cell[<span class="num">3</span>] &lt; minimum ? cell[<span class="num">3</span>] : minimum;
   minimum = cell[<span class="num">4</span>] &lt; minimum ? cell[<span class="num">4</span>] : minimum;
   <span class="kwa">return</span> minimum;
}

<span class="com">/* Calculate the lowest possible open cell if the piece is placed on the board.</span>
<span class="com"> * Used to later reduce the amount of time searching for open cells in the</span>
<span class="com"> * solve function.</span>
<span class="com"> */</span>
<span class="kwb">char</span> <span class="kwd">first_empty_cell</span>(<span class="kwb">char</span> *cell, <span class="kwb">char</span> minimum) {
   <span class="kwb">char</span> first_empty = minimum;
   <span class="kwa">while</span>(first_empty == cell[<span class="num">0</span>] || first_empty == cell[<span class="num">1</span>] ||
         first_empty == cell[<span class="num">2</span>] || first_empty == cell[<span class="num">3</span>] ||
         first_empty == cell[<span class="num">4</span>])
      first_empty++;
   <span class="kwa">return</span> first_empty;
}

<span class="com">/* Generate the unsigned long long int that will later be anded with the</span>
<span class="com"> * board to determine if it fits.</span>
<span class="com"> */</span>
<span class="kwb">unsigned long long</span> <span class="kwd">bitmask_from_cells</span>(<span class="kwb">char</span> *cell) {
   <span class="kwb">unsigned long long</span> piece_mask = <span class="num">0ULL</span>;
   <span class="kwb">int</span> i;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">5</span>; i++)
      piece_mask |= <span class="num">1ULL</span> &lt;&lt; cell[i];
   <span class="kwa">return</span> piece_mask;
}

<span class="com">/* Record the piece and other important information in arrays that will</span>
<span class="com"> * later be used by the solve function.</span>
<span class="com"> */</span>
<span class="kwb">void</span> <span class="kwd">record_piece</span>(<span class="kwb">int</span> piece, <span class="kwb">int</span> minimum, <span class="kwb">char</span> first_empty,
      <span class="kwb">unsigned long long</span> piece_mask) {
   pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask;
   next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty;
   piece_counts[piece][minimum]++;         
}


<span class="com">/* Fill the entire board going cell by cell.  If any cells are &quot;trapped&quot;</span>
<span class="com"> * they will be left alone.</span>
<span class="com"> */</span>
<span class="kwb">void</span> <span class="kwd">fill_contiguous_space</span>(<span class="kwb">char</span> *board, <span class="kwb">int</span> index) {
   <span class="kwa">if</span>(board[index] == <span class="num">1</span>)
      <span class="kwa">return</span>;
   board[index] = <span class="num">1</span>;
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, E))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, E));   
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, SE))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, SE));   
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, SW))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, SW));   
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, W))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, W));   
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, NW))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, NW));   
   <span class="kwa">if</span>(!<span class="kwd">out_of_bounds</span>(index, NE))
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, NE));   
}


<span class="com">/* To thin the number of pieces, I calculate if any of them trap any empty</span>
<span class="com"> * cells at the edges.  There are only a handful of exceptions where the</span>
<span class="com"> * the board can be solved with the trapped cells.  For example:  piece 8 can</span>
<span class="com"> * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0</span>
<span class="com"> * can split the board in half where both halves are viable.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">has_island</span>(<span class="kwb">char</span> *cell, <span class="kwb">int</span> piece) {
   <span class="kwb">char</span> temp_board[<span class="num">50</span>];
   <span class="kwb">char</span> c;
   <span class="kwb">int</span> i;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">50</span>; i++)
      temp_board[i] = <span class="num">0</span>;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">5</span>; i++)
      temp_board[((<span class="kwb">int</span>)cell[i])] = <span class="num">1</span>;
   i = <span class="num">49</span>;
   <span class="kwa">while</span>(temp_board[i] == <span class="num">1</span>)
      i--;
   <span class="kwd">fill_contiguous_space</span>(temp_board, i);
   c = <span class="num">0</span>;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">50</span>; i++)
      <span class="kwa">if</span>(temp_board[i] == <span class="num">0</span>)
         c++;
   <span class="kwa">if</span>(c == <span class="num">0</span> || (c == <span class="num">5</span> &amp;&amp; piece == <span class="num">8</span>) || (c == <span class="num">40</span> &amp;&amp; piece == <span class="num">8</span>) ||
         (c % <span class="num">5</span> == <span class="num">0</span> &amp;&amp; piece == <span class="num">0</span>))
      <span class="kwa">return</span> FALSE;
   <span class="kwa">else</span>
      <span class="kwa">return</span> TRUE;   
}


<span class="com">/* Calculate all six rotations of the specified piece at the specified index.</span>
<span class="com"> * We calculate only half of piece 3's rotations.  This is because any solution</span>
<span class="com"> * found has an identical solution rotated 180 degrees.  Thus we can reduce the</span>
<span class="com"> * number of attempted pieces in the solve algorithm by not including the 180-</span>
<span class="com"> * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave</span>
<span class="com"> * me the best time ;)</span>
<span class="com"> */</span>
 <span class="kwb">void</span> <span class="kwd">calc_six_rotations</span>(<span class="kwb">char</span> piece, <span class="kwb">char</span> index) {
   <span class="kwb">char</span> rotation, cell[<span class="num">5</span>];
   <span class="kwb">char</span> minimum, first_empty;
   <span class="kwb">unsigned long long</span> piece_mask;

   <span class="kwa">for</span>(rotation = <span class="num">0</span>; rotation &lt; <span class="num">6</span>; rotation++) {
      <span class="kwa">if</span>(piece != <span class="num">3</span> || rotation &lt; <span class="num">3</span>) { 
         <span class="kwd">calc_cell_indices</span>(cell, piece, index);
         <span class="kwa">if</span>(<span class="kwd">cells_fit_on_board</span>(cell, piece) &amp;&amp; !<span class="kwd">has_island</span>(cell, piece)) {
            minimum = <span class="kwd">minimum_of_cells</span>(cell);
            first_empty = <span class="kwd">first_empty_cell</span>(cell, minimum);
            piece_mask = <span class="kwd">bitmask_from_cells</span>(cell);
            <span class="kwd">record_piece</span>(piece, minimum, first_empty, piece_mask);
         }
      }
      <span class="kwd">rotate_piece</span>(piece);
   }
}

<span class="com">/* Calculate every legal rotation for each piece at each board location. */</span>
<span class="kwb">void</span> <span class="kwd">calc_pieces</span>(<span class="kwb">void</span>) {
   <span class="kwb">char</span> piece, index;

   <span class="kwa">for</span>(piece = <span class="num">0</span>; piece &lt; <span class="num">10</span>; piece++) {
      <span class="kwa">for</span>(index = <span class="num">0</span>; index &lt; <span class="num">50</span>; index++) {
         <span class="kwd">calc_six_rotations</span>(piece, index);
         <span class="kwd">flip_piece</span>(piece);
         <span class="kwd">calc_six_rotations</span>(piece, index);
      }
   }
}



<span class="com">/* Calculate all 32 possible states for a 5-bit row and all rows that will</span>
<span class="com"> * create islands that follow any of the 32 possible rows.  These pre-</span>
<span class="com"> * calculated 5-bit rows will be used to find islands in a partially solved</span>
<span class="com"> * board in the solve function.</span>
<span class="com"> */</span>
<span class="ppc">#define ROW_MASK 0x1F</span>
<span class="ppc">#define TRIPLE_MASK 0x7FFF</span>
<span class="kwb">char</span> all_rows[<span class="num">32</span>] = {<span class="num">0</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>, <span class="num">8</span>, <span class="num">9</span>, <span class="num">10</span>, <span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>, <span class="num">15</span>, <span class="num">16</span>,
      <span class="num">17</span>, <span class="num">18</span>, <span class="num">19</span>, <span class="num">20</span>, <span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>, <span class="num">26</span>, <span class="num">27</span>, <span class="num">28</span>, <span class="num">29</span>, <span class="num">30</span>, <span class="num">31</span>};
<span class="kwb">int</span> bad_even_rows[<span class="num">32</span>][<span class="num">32</span>];
<span class="kwb">int</span> bad_odd_rows[<span class="num">32</span>][<span class="num">32</span>];
<span class="kwb">int</span> bad_even_triple[<span class="num">32768</span>];
<span class="kwb">int</span> bad_odd_triple[<span class="num">32768</span>];

<span class="kwb">int</span> <span class="kwd">rows_bad</span>(<span class="kwb">char</span> row1, <span class="kwb">char</span> row2, <span class="kwb">int</span> even) {
   <span class="com">/* even is referring to row1 */</span>
   <span class="kwb">int</span> i, in_zeroes, group_okay;
   <span class="kwb">char</span> block, row2_shift;
   <span class="com">/* Test for blockages at same index and shifted index */</span>
   <span class="kwa">if</span>(even)
      row2_shift = ((row2 &lt;&lt; <span class="num">1</span>) &amp; ROW_MASK) | <span class="num">0x01</span>;
   <span class="kwa">else</span>
      row2_shift = (row2 &gt;&gt; <span class="num">1</span>) | <span class="num">0x10</span>;
   block = ((row1 ^ row2) &amp; row2) &amp; ((row1 ^ row2_shift) &amp; row2_shift);
   <span class="com">/* Test for groups of 0's */</span>
   in_zeroes = FALSE;
   group_okay = FALSE;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">5</span>; i++) {
      <span class="kwa">if</span>(row1 &amp; (<span class="num">1</span> &lt;&lt; i)) {
         <span class="kwa">if</span>(in_zeroes) {
            <span class="kwa">if</span>(!group_okay)
               <span class="kwa">return</span> TRUE;
            in_zeroes = FALSE;
            group_okay = FALSE;
         }
      } <span class="kwa">else</span> {
         <span class="kwa">if</span>(!in_zeroes)
            in_zeroes = TRUE;
         <span class="kwa">if</span>(!(block &amp; (<span class="num">1</span> &lt;&lt; i)))
            group_okay = TRUE;
      }
   }
   <span class="kwa">if</span>(in_zeroes)
      <span class="kwa">return</span> !group_okay;
   <span class="kwa">else</span>
      <span class="kwa">return</span> FALSE;
}

<span class="com">/* Check for cases where three rows checked sequentially cause a false</span>
<span class="com"> * positive.  One scenario is when 5 cells may be surrounded where piece 5</span>
<span class="com"> * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">triple_is_okay</span>(<span class="kwb">char</span> row1, <span class="kwb">char</span> row2, <span class="kwb">char</span> row3, <span class="kwb">int</span> even) {
   <span class="kwa">if</span>(even) {
      <span class="com">/* There are four cases:</span>
<span class="com">       * row1: 00011  00001  11001  10101</span>
<span class="com">       * row2: 01011  00101  10001  10001</span>
<span class="com">       * row3: 011??  00110  ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> ((row1 == <span class="num">0x03</span>) &amp;&amp; (row2 == <span class="num">0x0B</span>) &amp;&amp; ((row3 &amp; <span class="num">0x1C</span>) == <span class="num">0x0C</span>)) ||
            ((row1 == <span class="num">0x01</span>) &amp;&amp; (row2 == <span class="num">0x05</span>) &amp;&amp; (row3 == <span class="num">0x06</span>)) ||
            ((row1 == <span class="num">0x19</span>) &amp;&amp; (row2 == <span class="num">0x11</span>)) ||
            ((row1 == <span class="num">0x15</span>) &amp;&amp; (row2 == <span class="num">0x11</span>));
   } <span class="kwa">else</span> {
      <span class="com">/* There are two cases:</span>
<span class="com">       * row1: 10011  10101</span>
<span class="com">       * row2: 10001  10001</span>
<span class="com">       * row3: ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> ((row1 == <span class="num">0x13</span>) &amp;&amp; (row2 == <span class="num">0x11</span>)) ||
            ((row1 == <span class="num">0x15</span>) &amp;&amp; (row2 == <span class="num">0x11</span>));
   }
}


<span class="kwb">void</span> <span class="kwd">calc_rows</span>(<span class="kwb">void</span>) {
   <span class="kwb">int</span> row1, row2, row3;
   <span class="kwb">int</span> result1, result2;
   <span class="kwa">for</span>(row1 = <span class="num">0</span>; row1 &lt; <span class="num">32</span>; row1++) {
      <span class="kwa">for</span>(row2 = <span class="num">0</span>; row2 &lt; <span class="num">32</span>; row2++) {
         bad_even_rows[row1][row2] = <span class="kwd">rows_bad</span>(row1, row2, TRUE);
         bad_odd_rows[row1][row2] = <span class="kwd">rows_bad</span>(row1, row2, FALSE);
      }
   }
   <span class="kwa">for</span>(row1 = <span class="num">0</span>; row1 &lt; <span class="num">32</span>; row1++) {
      <span class="kwa">for</span>(row2 = <span class="num">0</span>; row2 &lt; <span class="num">32</span>; row2++) {
         <span class="kwa">for</span>(row3 = <span class="num">0</span>; row3 &lt; <span class="num">32</span>; row3++) {
            result1 = bad_even_rows[row1][row2];
            result2 = bad_odd_rows[row2][row3];
            <span class="kwa">if</span>(result1 == FALSE &amp;&amp; result2 == TRUE
                  &amp;&amp; <span class="kwd">triple_is_okay</span>(row1, row2, row3, TRUE))
               bad_even_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = FALSE;
            <span class="kwa">else</span>
               bad_even_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = result1 || result2;

            result1 = bad_odd_rows[row1][row2];
            result2 = bad_even_rows[row2][row3];
            <span class="kwa">if</span>(result1 == FALSE &amp;&amp; result2 == TRUE
                  &amp;&amp; <span class="kwd">triple_is_okay</span>(row1, row2, row3, FALSE))
               bad_odd_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = FALSE;
            <span class="kwa">else</span>
               bad_odd_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = result1 || result2;
         }
      }
   }
}



<span class="com">/* Calculate islands while solving the board.</span>
<span class="com"> */</span>
<span class="kwb">int</span> <span class="kwd">boardHasIslands</span>(<span class="kwb">char</span> cell) {
   <span class="com">/* Too low on board, don't bother checking */</span>
   <span class="kwa">if</span>(cell &gt;= <span class="num">40</span>)
      <span class="kwa">return</span> FALSE;
   <span class="kwb">int</span> current_triple = (board &gt;&gt; ((cell / <span class="num">5</span>) * <span class="num">5</span>)) &amp; TRIPLE_MASK;
   <span class="kwa">if</span>((cell / <span class="num">5</span>) % <span class="num">2</span>)
      <span class="kwa">return</span> bad_odd_triple[current_triple];
   <span class="kwa">else</span>
      <span class="kwa">return</span> bad_even_triple[current_triple];
}


<span class="com">/* The recursive solve algorithm.  Try to place each permutation in the upper-</span>
<span class="com"> * leftmost empty cell.  Mark off available pieces as it goes along.</span>
<span class="com"> * Because the board is a bit mask, the piece number and bit mask must be saved</span>
<span class="com"> * at each successful piece placement.  This data is used to create a 50 char</span>
<span class="com"> * array if a solution is found.</span>
<span class="com"> */</span>
<span class="kwb">short</span> avail = <span class="num">0x03FF</span>;
<span class="kwb">char</span> sol_nums[<span class="num">10</span>];
<span class="kwb">unsigned long long</span> sol_masks[<span class="num">10</span>];
<span class="kwb">signed char</span> solutions[<span class="num">2100</span>][<span class="num">50</span>];
<span class="kwb">int</span> solution_count = <span class="num">0</span>;
<span class="kwb">int</span> max_solutions = <span class="num">2100</span>;

<span class="kwb">void</span> <span class="kwd">record_solution</span>(<span class="kwb">void</span>) {
   <span class="kwb">int</span> sol_no, index;
   <span class="kwb">unsigned long long</span> sol_mask;
   <span class="kwa">for</span>(sol_no = <span class="num">0</span>; sol_no &lt; <span class="num">10</span>; sol_no++) {
      sol_mask = sol_masks[sol_no];
      <span class="kwa">for</span>(index = <span class="num">0</span>; index &lt; <span class="num">50</span>; index++) {
         <span class="kwa">if</span>(sol_mask &amp; <span class="num">1ULL</span>) {
            solutions[solution_count][index] = sol_nums[sol_no];
            <span class="com">/* Board rotated 180 degrees is a solution too! */</span>
            solutions[solution_count+<span class="num">1</span>][<span class="num">49</span>-index] = sol_nums[sol_no];
         }
         sol_mask = sol_mask &gt;&gt; <span class="num">1</span>;
      }
   }
   solution_count += <span class="num">2</span>;
}

<span class="kwb">void</span> <span class="kwd">solve</span>(<span class="kwb">int</span> depth, <span class="kwb">int</span> cell) {
   <span class="kwb">int</span> piece, rotation, max_rots;
   <span class="kwb">unsigned long long</span> *piece_mask;
   <span class="kwb">short</span> piece_no_mask;
   
   <span class="kwa">if</span>(solution_count &gt;= max_solutions)
      <span class="kwa">return</span>;

   <span class="kwa">while</span>(board &amp; (<span class="num">1ULL</span> &lt;&lt; cell))
      cell++;

   <span class="kwa">for</span>(piece = <span class="num">0</span>; piece &lt; <span class="num">10</span>; piece++) {
      piece_no_mask = <span class="num">1</span> &lt;&lt; piece;
      <span class="kwa">if</span>(!(avail &amp; piece_no_mask))
         <span class="kwa">continue</span>;
      avail ^= piece_no_mask;
      max_rots = piece_counts[piece][cell];
      piece_mask = pieces[piece][cell];
      <span class="kwa">for</span>(rotation = <span class="num">0</span>; rotation &lt; max_rots; rotation++) {
         <span class="kwa">if</span>(!(board &amp; *(piece_mask + rotation))) {
            sol_nums[depth] = piece;
            sol_masks[depth] = *(piece_mask + rotation);
            <span class="kwa">if</span>(depth == <span class="num">9</span>) {
               <span class="com">/* Solution found!!!!!11!!ONE! */</span>
               <span class="kwd">record_solution</span>();
               avail ^= piece_no_mask;
               <span class="kwa">return</span>;
            }
            board |= *(piece_mask + rotation);
            <span class="kwa">if</span>(!<span class="kwd">boardHasIslands</span>(next_cell[piece][cell][rotation]))
               <span class="kwd">solve</span>(depth + <span class="num">1</span>, next_cell[piece][cell][rotation]);
            board ^= *(piece_mask + rotation);
         }
      }
      avail ^= piece_no_mask;
   }
}


<span class="com">/* qsort comparator - used to find first and last solutions */</span>
<span class="kwb">int</span> <span class="kwd">solution_sort</span>(<span class="kwb">const void</span> *elem1, <span class="kwb">const void</span> *elem2) {
   <span class="kwb">signed char</span> *char1 = (<span class="kwb">signed char</span> *) elem1;
   <span class="kwb">signed char</span> *char2 = (<span class="kwb">signed char</span> *) elem2;
   <span class="kwb">int</span> i = <span class="num">0</span>;
   <span class="kwa">while</span>(i &lt; <span class="num">50</span> &amp;&amp; char1[i] == char2[i])
      i++;
   <span class="kwa">return</span> char1[i] - char2[i];
}


<span class="com">/* pretty print a board in the specified hexagonal format */</span>
<span class="kwb">void</span> <span class="kwd">pretty</span>(<span class="kwb">signed char</span> *b) {
   <span class="kwb">int</span> i;
   <span class="kwa">for</span>(i = <span class="num">0</span>; i &lt; <span class="num">50</span>; i += <span class="num">10</span>) {
      <span class="kwd">printf</span>(<span class="str">&quot;%c %c %c %c %c</span> <span class="esc">\n</span> <span class="str">%c %c %c %c %c</span> <span class="esc">\n</span><span class="str">&quot;</span>, b[i]+<span class="str">'0'</span>, b[i+<span class="num">1</span>]+<span class="str">'0'</span>,
            b[i+<span class="num">2</span>]+<span class="str">'0'</span>, b[i+<span class="num">3</span>]+<span class="str">'0'</span>, b[i+<span class="num">4</span>]+<span class="str">'0'</span>, b[i+<span class="num">5</span>]+<span class="str">'0'</span>, b[i+<span class="num">6</span>]+<span class="str">'0'</span>,
            b[i+<span class="num">7</span>]+<span class="str">'0'</span>, b[i+<span class="num">8</span>]+<span class="str">'0'</span>, b[i+<span class="num">9</span>]+<span class="str">'0'</span>);
   }
   <span class="kwd">printf</span>(<span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>);
}

<span class="kwb">int</span> <span class="kwd">main</span>(<span class="kwb">int</span> argc, <span class="kwb">char</span> **argv) {
   <span class="kwa">if</span>(argc &gt; <span class="num">1</span>)
      max_solutions = <span class="kwd">atoi</span>(argv[<span class="num">1</span>]);
   <span class="kwd">calc_pieces</span>();
   <span class="kwd">calc_rows</span>();
   <span class="kwd">solve</span>(<span class="num">0</span>, <span class="num">0</span>);
   <span class="kwd">printf</span>(<span class="str">&quot;%d solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span>, solution_count);
   <span class="kwd">qsort</span>(solutions, solution_count, <span class="num">50</span> * <span class="kwa">sizeof</span>(<span class="kwb">signed char</span>), solution_sort);
   <span class="kwd">pretty</span>(solutions[<span class="num">0</span>]);
   <span class="kwd">pretty</span>(solutions[solution_count-<span class="num">1</span>]);
   <span class="kwa">return</span> <span class="num">0</span>;
}
