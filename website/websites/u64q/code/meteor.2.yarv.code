<span class="slc"># The Computer Language Benchmarks Game</span>
<span class="slc"># http://benchmarksgame.alioth.debian.org</span>
<span class="slc">#   contributed by Kevin Barnes (Ruby novice)</span>

<span class="slc"># PROGRAM:  the main body is at the bottom.  </span>
<span class="slc">#   1) read about the problem here: http://www-128.ibm.com/developerworks/java/library/j-javaopt/</span>
<span class="slc">#   2) see how I represent a board as a bitmask by reading the blank_board comments</span>
<span class="slc">#   3) read as your mental paths take you</span>

<span class="slc"># class to represent all information about a particular rotation of a particular piece</span>
<span class="kwa">class</span> Rotation
  <span class="slc"># an array (by location) containing a bit mask for how the piece maps at the given location.</span>
  <span class="slc"># if the rotation is illegal at that location the mask will contain false</span>
  attr_reader <span class="kwc">:start_masks</span>
  
  <span class="slc"># maps a direction to a relative location.  these differ depending on whether it is an even or</span>
  <span class="slc"># odd row being mapped from</span>
  &#64;<span class="kwb">&#64;rotation_even_adder</span> = { :west =&gt; -1, :east =&gt; 1, :nw =&gt; -7, :ne =&gt; -6, :sw =&gt; 5, :se =&gt; 6 }
  &#64;<span class="kwb">&#64;rotation_odd_adder</span> = { :west =&gt; -1, :east =&gt; 1, :nw =&gt; -6, :ne =&gt; -5, :sw =&gt; 6, :se =&gt; 7 }
  
  <span class="kwa">def</span> <span class="kwd">initialize</span>( directions <span class="opt">)</span>
    <span class="kwb">&#64;even_offsets</span>, <span class="kwb">&#64;odd_offsets</span> = <span class="kwd">normalize_offsets</span>( <span class="kwd">get_values</span>( directions <span class="opt">))</span>
      
    <span class="kwb">&#64;even_mask</span> = <span class="kwd">mask_for_offsets</span>( <span class="kwb">&#64;even_offsets</span><span class="opt">)</span>
    <span class="kwb">&#64;odd_mask</span> = <span class="kwd">mask_for_offsets</span>( <span class="kwb">&#64;odd_offsets</span><span class="opt">)</span>

    <span class="kwb">&#64;start_masks</span> = Array.<span class="kwd">new</span>(<span class="num">60</span><span class="opt">)</span>
    
    <span class="slc"># create the rotational masks by placing the base mask at the location and seeing if</span>
    <span class="slc"># 1) it overlaps the boundries and 2) it produces a prunable board.  if either of these</span>
    <span class="slc"># is true the piece cannot be placed</span>
    <span class="num">0</span>.<span class="kwd">upto</span>(<span class="num">59</span><span class="opt">)</span> <span class="kwa">do</span> | offset |
      mask = <span class="kwd">is_even</span>(offset<span class="opt">)</span> ? (<span class="kwb">&#64;even_mask</span> &lt;&lt; offset<span class="opt">)</span> : (<span class="kwb">&#64;odd_mask</span> &lt;&lt; offset<span class="opt">)</span>
      <span class="kwa">if</span> (blank_board &amp; mask == <span class="num">0</span> &amp;&amp; !<span class="kwd">prunable</span>(blank_board | mask, <span class="num">0</span>, <span class="kwa">true</span><span class="opt">))</span> <span class="kwa">then</span>
        imask = <span class="kwd">compute_required</span>( mask, offset<span class="opt">)</span>
        <span class="kwb">&#64;start_masks</span>[offset] = [ mask, imask, imask | mask ]
      <span class="kwa">else</span>
        <span class="kwb">&#64;start_masks</span>[offset] = <span class="kwa">false</span> 
      <span class="kwa">end</span>
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  
  <span class="kwa">def</span> <span class="kwd">compute_required</span>( mask, offset <span class="opt">)</span>
    board = blank_board
    <span class="num">0</span>.<span class="kwd">upto</span>(offset<span class="opt">)</span> { | i | board |= 1 &lt;&lt; i }
    board |= mask
    <span class="kwa">return</span> <span class="num">0</span> <span class="kwa">if</span> (!<span class="kwd">prunable</span>(board | mask, offset<span class="opt">))</span>
    board = <span class="kwd">flood_fill</span>(board,<span class="num">58</span><span class="opt">)</span>
    count = <span class="num">0</span>
    imask = <span class="num">0</span>
    <span class="num">0</span>.<span class="kwd">upto</span>(<span class="num">59</span><span class="opt">)</span> <span class="kwa">do</span> | i |
      <span class="kwa">if</span> (board[i] == <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
        imask |= (<span class="num">1</span> &lt;&lt; i<span class="opt">)</span> 
        count += <span class="num">1</span>
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    (count &gt; <span class="num">0</span> &amp;&amp; count &lt; <span class="num">5</span><span class="opt">)</span> ? imask : <span class="num">0</span>
  <span class="kwa">end</span>
  
  <span class="kwa">def</span> <span class="kwd">flood_fill</span>( board, location<span class="opt">)</span>
    <span class="kwa">return</span> board <span class="kwa">if</span> (board[location] == <span class="num">1</span><span class="opt">)</span>
    board |= <span class="num">1</span> &lt;&lt; location
    row, col = location.<span class="kwd">divmod</span>(<span class="num">6</span><span class="opt">)</span>
    board = <span class="kwd">flood_fill</span>( board, location - <span class="num">1</span><span class="opt">)</span> <span class="kwa">if</span> (col &gt; <span class="num">0</span><span class="opt">)</span>
    board = <span class="kwd">flood_fill</span>( board, location + <span class="num">1</span><span class="opt">)</span> <span class="kwa">if</span> (col &lt; <span class="num">4</span><span class="opt">)</span>
    <span class="kwa">if</span> (row % <span class="num">2</span> == <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
      board = <span class="kwd">flood_fill</span>( board, location - <span class="num">7</span><span class="opt">)</span> <span class="kwa">if</span> (col &gt; <span class="num">0</span> &amp;&amp; row &gt; <span class="num">0</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location - <span class="num">6</span><span class="opt">)</span> <span class="kwa">if</span> (row &gt; <span class="num">0</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location + <span class="num">6</span><span class="opt">)</span> <span class="kwa">if</span> (row &lt; <span class="num">9</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location + <span class="num">5</span><span class="opt">)</span> <span class="kwa">if</span> (col &gt; <span class="num">0</span> &amp;&amp; row &lt; <span class="num">9</span><span class="opt">)</span>
    <span class="kwa">else</span>
      board = <span class="kwd">flood_fill</span>( board, location - <span class="num">5</span><span class="opt">)</span> <span class="kwa">if</span> (col &lt; <span class="num">4</span> &amp;&amp; row &gt; <span class="num">0</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location - <span class="num">6</span><span class="opt">)</span> <span class="kwa">if</span> (row &gt; <span class="num">0</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location + <span class="num">6</span><span class="opt">)</span> <span class="kwa">if</span> (row &lt; <span class="num">9</span><span class="opt">)</span>
      board = <span class="kwd">flood_fill</span>( board, location + <span class="num">7</span><span class="opt">)</span> <span class="kwa">if</span> (col &lt; <span class="num">4</span> &amp;&amp; row &lt; <span class="num">9</span><span class="opt">)</span>
    <span class="kwa">end</span>
    board
  <span class="kwa">end</span>
  
  <span class="slc"># given a location, produces a list of relative locations covered by the piece at this rotation</span>
  <span class="kwa">def</span> <span class="kwd">offsets</span>( location<span class="opt">)</span>
    <span class="kwa">if</span> <span class="kwd">is_even</span>( location<span class="opt">)</span> <span class="kwa">then</span>
      <span class="kwb">&#64;even_offsets</span>.collect { | value | value + location }
    <span class="kwa">else</span>
      <span class="kwb">&#64;odd_offsets</span>.collect { | value | value + location }
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  
  <span class="slc"># returns a set of offsets relative to the top-left most piece of the rotation (by even or odd rows)</span>
  <span class="slc"># this is hard to explain. imagine we have this partial board:</span>
  <span class="slc">#   0 0 0 0 0 x        [positions 0-5]</span>
  <span class="slc">#    0 0 1 1 0 x       [positions 6-11]</span>
  <span class="slc">#   0 0 1 0 0 x        [positions 12-17]</span>
  <span class="slc">#    0 1 0 0 0 x       [positions 18-23]</span>
  <span class="slc">#   0 1 0 0 0 x        [positions 24-29]</span>
  <span class="slc">#    0 0 0 0 0 x       [positions 30-35]</span>
  <span class="slc">#       ...</span>
  <span class="slc"># The top-left of the piece is at position 8, the</span>
  <span class="slc"># board would be passed as a set of positions (values array) containing [8,9,14,19,25] not necessarily in that</span>
  <span class="slc"># sorted order.  Since that array starts on an odd row, the offsets for an odd row are: [0,1,6,11,17] obtained </span>
  <span class="slc"># by subtracting 8 from everything.  Now imagine the piece shifted up and to the right so it's on an even row:</span>
  <span class="slc">#   0 0 0 1 1 x        [positions 0-5]</span>
  <span class="slc">#    0 0 1 0 0 x       [positions 6-11]</span>
  <span class="slc">#   0 0 1 0 0 x        [positions 12-17]</span>
  <span class="slc">#    0 1 0 0 0 x       [positions 18-23]</span>
  <span class="slc">#   0 0 0 0 0 x        [positions 24-29]</span>
  <span class="slc">#    0 0 0 0 0 x       [positions 30-35]</span>
  <span class="slc">#       ...</span>
  <span class="slc"># Now the positions are [3,4,8,14,19] which after subtracting the lowest value (3) gives [0,1,5,11,16] thus, the </span>
  <span class="slc"># offsets for this particular piece are (in even, odd order) [0,1,5,11,16],[0,1,6,11,17] which is what</span>
  <span class="slc"># this function would return</span>
  <span class="kwa">def</span> <span class="kwd">normalize_offsets</span>( values<span class="opt">)</span>
    min = values.min
    even_min = <span class="kwd">is_even</span>(min<span class="opt">)</span>
    other_min = even_min ? min + <span class="num">6</span> : min + <span class="num">7</span>
    other_values = values.collect <span class="kwa">do</span> | value | 
      <span class="kwa">if</span> <span class="kwd">is_even</span>(value<span class="opt">)</span> <span class="kwa">then</span> 
        value + <span class="num">6</span> - other_min 
      <span class="kwa">else</span> 
        value + <span class="num">7</span> - other_min 
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    values.collect! { | value | value - min }
    
    <span class="kwa">if</span> even_min <span class="kwa">then</span>
      [values, other_values]
    <span class="kwa">else</span>
      [other_values, values]
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  
  <span class="slc"># produce a bitmask representation of an array of offset locations</span>
  <span class="kwa">def</span> <span class="kwd">mask_for_offsets</span>( offsets <span class="opt">)</span>
    mask = <span class="num">0</span>
    offsets.each { | value | mask = mask + ( 1 &lt;&lt; value ) }
    mask
  <span class="kwa">end</span>

  <span class="slc"># finds a &quot;safe&quot; position that a position as described by a list of directions can be placed</span>
  <span class="slc"># without falling off any edge of the board.  the values returned a location to place the first piece</span>
  <span class="slc"># at so it will fit after making the described moves</span>
  <span class="kwa">def</span> <span class="kwd">start_adjust</span>( directions <span class="opt">)</span>
    south = east = <span class="num">0</span>;
    directions.each <span class="kwa">do</span> | direction |
      east += <span class="num">1</span> <span class="kwa">if</span> ( direction == <span class="kwc">:sw</span> || direction == <span class="kwc">:nw</span> || direction == <span class="kwc">:west</span> <span class="opt">)</span>
      south += <span class="num">1</span> <span class="kwa">if</span> ( direction == <span class="kwc">:nw</span> || direction == <span class="kwc">:ne</span> <span class="opt">)</span>   
    <span class="kwa">end</span>
    south * <span class="num">6</span> + east
  <span class="kwa">end</span>

  <span class="slc"># given a set of directions places the piece (as defined by a set of directions) on the board at </span>
  <span class="slc"># a location that will not take it off the edge</span>
  <span class="kwa">def</span> <span class="kwd">get_values</span> ( directions <span class="opt">)</span>
    start = <span class="kwd">start_adjust</span>(directions<span class="opt">)</span>
    values = [ start ]
    directions.each <span class="kwa">do</span> | direction |
      <span class="kwa">if</span> (start % <span class="num">12</span> &gt;= <span class="num">6</span><span class="opt">)</span> <span class="kwa">then</span> 
        start += &#64;<span class="kwb">&#64;rotation_odd_adder</span>[direction]
      <span class="kwa">else</span> 
        start += &#64;<span class="kwb">&#64;rotation_even_adder</span>[direction]
      <span class="kwa">end</span>
      values += [ start ]
    <span class="kwa">end</span>
    
    <span class="slc"># some moves take you back to an existing location, we'll strip duplicates</span>
    values.uniq
  <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="slc"># describes a piece and caches information about its rotations to as to be efficient for iteration</span>
<span class="slc"># ATTRIBUTES:</span>
<span class="slc">#   rotations -- all the rotations of the piece</span>
<span class="slc">#   type -- a numeic &quot;name&quot; of the piece</span>
<span class="slc">#   masks -- an array by location of all legal rotational masks (a n inner array) for that location</span>
<span class="slc">#   placed -- the mask that this piece was last placed at (not a location, but the actual mask used)</span>
<span class="kwa">class</span> Piece
  attr_reader <span class="kwc">:rotations</span>, <span class="kwc">:type</span>, <span class="kwc">:masks</span> 
  attr_accessor <span class="kwc">:placed</span> 
  
  <span class="slc"># transform hashes that change one direction into another when you either flip or rotate a set of directions</span>
  &#64;<span class="kwb">&#64;flip_converter</span> = { :west =&gt; :west, :east =&gt; :east, :nw =&gt; :sw, :ne =&gt; :se, :sw =&gt; :nw, :se =&gt; :ne }
  &#64;<span class="kwb">&#64;rotate_converter</span> = { :west =&gt; :nw, :east =&gt; :se, :nw =&gt; :ne, :ne =&gt; :east, :sw =&gt; :west, :se =&gt; :sw }
  
  <span class="kwa">def</span> <span class="kwd">initialize</span>( directions, type <span class="opt">)</span>
    <span class="kwb">&#64;type</span> = type
    <span class="kwb">&#64;rotations</span> = Array.<span class="kwd">new</span>(<span class="opt">)</span>;
    <span class="kwb">&#64;map</span> = {}
    
    <span class="kwd">generate_rotations</span>( directions <span class="opt">)</span>
    directions.collect! { | value | &#64;&#64;flip_converter[value] }
    <span class="kwd">generate_rotations</span>( directions <span class="opt">)</span>
    
    <span class="slc"># creates the masks AND a map that returns [location, rotation] for any given mask</span>
    <span class="slc"># this is used when a board is found and we want to draw it, otherwise the map is unused</span>
    <span class="kwb">&#64;masks</span> = Array.<span class="kwd">new</span>(<span class="opt">)</span>;
    <span class="num">0</span>.<span class="kwd">upto</span>(<span class="num">59</span><span class="opt">)</span> <span class="kwa">do</span> | i |
      even = <span class="kwa">true</span>
      <span class="kwb">&#64;masks</span>[i] = <span class="kwb">&#64;rotations</span>.collect <span class="kwa">do</span> | rotation | 
        mask = rotation.start_masks[i]
        <span class="kwb">&#64;map</span>[mask[<span class="num">0</span>]] = [ i, rotation ] <span class="kwa">if</span> (mask<span class="opt">)</span> 
        mask || <span class="kwa">nil</span>
      <span class="kwa">end</span>
      <span class="kwb">&#64;masks</span>[i].compact!
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  
  <span class="slc"># rotates a set of directions through all six angles and adds a Rotation to the list for each one</span>
  <span class="kwa">def</span> <span class="kwd">generate_rotations</span>( directions <span class="opt">)</span> 
    <span class="num">6</span>.times <span class="kwa">do</span>
      rotations.<span class="kwd">push</span>( Rotation.<span class="kwd">new</span>(directions<span class="opt">))</span>
      directions.collect! { | value | &#64;&#64;rotate_converter[value] }
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  
  <span class="slc"># given a board string, adds this piece to the board at whatever location/rotation</span>
  <span class="slc"># important: the outbound board string is 5 wide, the normal location notation is six wide (padded)</span>
  <span class="kwa">def</span> <span class="kwd">fill_string</span>( board_string<span class="opt">)</span>
    location, rotation = <span class="kwb">&#64;map</span>[<span class="kwb">&#64;placed</span>]
    rotation.<span class="kwd">offsets</span>(location<span class="opt">)</span>.each <span class="kwa">do</span> | offset |
      row, col = offset.<span class="kwd">divmod</span>(<span class="num">6</span><span class="opt">)</span>
      board_string[ row*<span class="num">5</span> + col, <span class="num">1</span> ] = <span class="kwb">&#64;type</span>.to_s
    <span class="kwa">end</span>
  <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="slc"># a blank bit board having this form:</span>
<span class="slc">#</span>
<span class="slc">#    0 0 0 0 0 1</span>
<span class="slc">#     0 0 0 0 0 1</span>
<span class="slc">#    0 0 0 0 0 1</span>
<span class="slc">#     0 0 0 0 0 1</span>
<span class="slc">#    0 0 0 0 0 1</span>
<span class="slc">#     0 0 0 0 0 1</span>
<span class="slc">#    0 0 0 0 0 1</span>
<span class="slc">#     0 0 0 0 0 1</span>
<span class="slc">#    0 0 0 0 0 1</span>
<span class="slc">#     0 0 0 0 0 1</span>
<span class="slc">#    1 1 1 1 1 1</span>
<span class="slc">#</span>
<span class="slc"># where left lest significant bit is the top left and the most significant is the lower right </span>
<span class="slc"># the actual board only consists of the 0 places, the 1 places are blockers to keep things from running </span>
<span class="slc"># off the edges or bottom</span>
<span class="kwa">def</span> blank_board
  <span class="num">0b111111100000100000100000100000100000100000100000100000100000100000</span>
<span class="kwa">end</span>

<span class="kwa">def</span> full_board
  <span class="num">0b111111111111111111111111111111111111111111111111111111111111111111</span>
<span class="kwa">end</span>

<span class="slc"># determines if a location (bit position) is in an even row</span>
<span class="kwa">def</span> <span class="kwd">is_even</span>( location<span class="opt">)</span>
  (location % <span class="num">12</span><span class="opt">)</span> &lt; <span class="num">6</span>
<span class="kwa">end</span>

<span class="slc"># support function that create three utility maps:</span>
<span class="slc">#  &#64;&#64;converter -- for each row an array that maps a five bit row (via array mapping) </span>
<span class="slc">#                 to the a a five bit representation of the bits below it</span>
<span class="slc">#  &#64;&#64;bit_count -- maps a five bit row (via array mapping) to the number of 1s in the row</span>
<span class="slc">#  &#64;&#64;new_regions -- maps a five bit row (via array mapping) to an array of &quot;region&quot; arrays</span>
<span class="slc">#                   a region array has three values the first is a mask of bits in the region, </span>
<span class="slc">#                   the second is the count of those bits and the third is identical to the first</span>
<span class="slc">#                   examples:</span>
<span class="slc">#                           0b10010 =&gt; [ 0b01100, 2, 0b01100 ], [ 0b00001, 1, 0b00001]</span>
<span class="slc">#                           0b01010 =&gt; [ 0b10000, 1, 0b10000 ], [ 0b00100, 1, 0b00100 ], [ 0b00001, 1, 0b00001]</span>
<span class="slc">#                           0b10001 =&gt; [ 0b01110, 3, 0b01110 ]</span>
<span class="kwa">def</span> create_collector_support
  odd_map = [<span class="num">0b11</span>, <span class="num">0b110</span>, <span class="num">0b1100</span>, <span class="num">0b11000</span>, <span class="num">0b10000</span>] 
  even_map = [<span class="num">0b1</span>, <span class="num">0b11</span>, <span class="num">0b110</span>, <span class="num">0b1100</span>, <span class="num">0b11000</span>] 
  
  all_odds = Array.<span class="kwd">new</span>(<span class="num">0b100000</span><span class="opt">)</span>
  all_evens = Array.<span class="kwd">new</span>(<span class="num">0b100000</span><span class="opt">)</span>
  bit_counts = Array.<span class="kwd">new</span>(<span class="num">0b100000</span><span class="opt">)</span>
  new_regions = Array.<span class="kwd">new</span>(<span class="num">0b100000</span><span class="opt">)</span>
  <span class="num">0</span>.<span class="kwd">upto</span>(<span class="num">0b11111</span><span class="opt">)</span> <span class="kwa">do</span> | i |
    bit_count = odd = even = <span class="num">0</span>
    <span class="num">0</span>.<span class="kwd">upto</span>(<span class="num">4</span><span class="opt">)</span> <span class="kwa">do</span> | bit |
      <span class="kwa">if</span> (i[bit] == <span class="num">1</span><span class="opt">)</span> <span class="kwa">then</span>
        bit_count += <span class="num">1</span>
        odd |= odd_map[bit]
        even |= even_map[bit]
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    all_odds[i] = odd
    all_evens[i] = even
    bit_counts[i] = bit_count
    new_regions[i] = <span class="kwd">create_regions</span>( i<span class="opt">)</span>
  <span class="kwa">end</span>

  &#64;<span class="kwb">&#64;converter</span> = []
  <span class="num">10</span>.times { | row | &#64;&#64;converter.push((row % 2 == 0) ? all_evens : all_odds) }
  &#64;<span class="kwb">&#64;bit_counts</span> = bit_counts
  &#64;<span class="kwb">&#64;regions</span> = new_regions.collect { | set | set.collect { | value | [ value, bit_counts[value], value] } }
<span class="kwa">end</span>
 
<span class="slc"># determines if a board is punable, meaning that there is no possibility that it </span>
<span class="slc"># can be filled up with pieces.  A board is prunable if there is a grouping of unfilled spaces</span>
<span class="slc"># that are not a multiple of five.  The following board is an example of a prunable board:</span>
<span class="slc">#    0 0 1 0 0</span>
<span class="slc">#     0 1 0 0 0</span>
<span class="slc">#    1 1 0 0 0</span>
<span class="slc">#     0 1 0 0 0</span>
<span class="slc">#    0 0 0 0 0</span>
<span class="slc">#       ...</span>
<span class="slc">#</span>
<span class="slc"># This board is prunable because the top left corner is only 3 bits in area, no piece will ever fit it</span>
<span class="slc"># parameters:</span>
<span class="slc">#   board -- an initial bit board (6 bit padded rows, see blank_board for format)</span>
<span class="slc">#   location -- starting location, everything above and to the left is already full</span>
<span class="slc">#   slotting -- set to true only when testing initial pieces, when filling normally</span>
<span class="slc">#               additional assumptions are possible</span>
<span class="slc">#</span>
<span class="slc"># Algorithm:</span>
<span class="slc">#    The algorithm starts at the top row (as determined by location) and iterates a row at a time</span>
<span class="slc">#    maintainng counts of active open areas (kept in the collector array) each collector contains</span>
<span class="slc">#    three values at the start of an iteration: </span>
<span class="slc">#          0: mask of bits that would be adjacent to the collector in this row</span>
<span class="slc">#          1: the number of bits collected so far</span>
<span class="slc">#          2: a scratch space starting as zero, but used during the computation to represent</span>
<span class="slc">#             the empty bits in the new row that are adjacent (position 0)</span>
<span class="slc">#  The exact procedure is described in-code </span>
<span class="kwa">def</span> <span class="kwd">prunable</span>( board, location, slotting = <span class="kwa">false</span><span class="opt">)</span>
  collectors = []
  <span class="slc"># loop accross the rows</span>
  (location / <span class="num">6</span><span class="opt">)</span>.to_i.<span class="kwd">upto</span>(<span class="num">9</span><span class="opt">)</span> <span class="kwa">do</span> | row_on | 
    <span class="slc"># obtain a set of regions representing the bits of the curent row.  </span>
    regions = &#64;<span class="kwb">&#64;regions</span>[(board &gt;&gt; (row_on * <span class="num">6</span><span class="opt">))</span> &amp; <span class="num">0b11111</span>]
    converter = &#64;<span class="kwb">&#64;converter</span>[row_on]
    
    <span class="slc"># track the number of collectors at the start of the cycle so that</span>
    <span class="slc"># we don't compute against newly created collectors, only existing collectors</span>
    initial_collector_count = collectors.length
    
    <span class="slc"># loop against the regions.  For each region of the row</span>
    <span class="slc"># we will see if it connects to one or more existing collectors.</span>
    <span class="slc"># if it connects to 1 collector, the bits from the region are added to the </span>
    <span class="slc"># bits of the collector and the mask is placed in collector[2]</span>
    <span class="slc"># If the region overlaps more than one collector then all the collectors</span>
    <span class="slc"># it overlaps with are merged into the first one (the others are set to nil in the array) </span>
    <span class="slc"># if NO collectors are found then the region is copied as a new collector</span>
    regions.each <span class="kwa">do</span> | region |
      collector_found = <span class="kwa">nil</span>
      region_mask = region[<span class="num">2</span>]
      initial_collector_count.times <span class="kwa">do</span> | collector_num |
        collector = collectors[collector_num]
        <span class="kwa">if</span> (collector<span class="opt">)</span> <span class="kwa">then</span>
          collector_mask = collector[<span class="num">0</span>]
          <span class="kwa">if</span> (collector_mask &amp; region_mask != <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
            <span class="kwa">if</span> (collector_found<span class="opt">)</span> <span class="kwa">then</span>
              collector_found[<span class="num">0</span>] |= collector_mask
              collector_found[<span class="num">1</span>] += collector[<span class="num">1</span>]
              collector_found[<span class="num">2</span>] |= collector[<span class="num">2</span>]
              collectors[collector_num] = <span class="kwa">nil</span>
            <span class="kwa">else</span>
              collector_found = collector
              collector[<span class="num">1</span>] += region[<span class="num">1</span>]
              collector[<span class="num">2</span>] |= region_mask
            <span class="kwa">end</span>
          <span class="kwa">end</span>
        <span class="kwa">end</span>
      <span class="kwa">end</span>
      <span class="kwa">if</span> (collector_found == <span class="kwa">nil</span><span class="opt">)</span> <span class="kwa">then</span>
        collectors.<span class="kwd">push</span>(Array.<span class="kwd">new</span>(region<span class="opt">))</span>
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    
    <span class="slc"># check the existing collectors, if any collector overlapped no bits in the region its [2] value will</span>
    <span class="slc"># be zero.  The size of any such reaason is tested if it is not a muliple of five true is returned since</span>
    <span class="slc"># the board is prunable.  if it is a multiple of five it is removed.</span>
    <span class="slc"># Collector that are still active have a new adjacent value [0] set based n the matched bits </span>
    <span class="slc"># and have [2] cleared out for the next cycle.</span>
    collectors.length.times <span class="kwa">do</span> | collector_num |
      collector = collectors[collector_num]
      <span class="kwa">if</span> (collector<span class="opt">)</span> <span class="kwa">then</span>
        <span class="kwa">if</span> (collector[<span class="num">2</span>] == <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
          <span class="kwa">return true if</span> (collector[<span class="num">1</span>] % <span class="num">5</span> != <span class="num">0</span><span class="opt">)</span>
          collectors[collector_num] = <span class="kwa">nil</span>
        <span class="kwa">else</span>
          <span class="slc"># if a collector matches all bits in the row then we can return unprunable early for the </span>
          <span class="slc"># follwing reasons:</span>
          <span class="slc">#    1) there can be no more unavailable bits bince we fill from the top left downward</span>
          <span class="slc">#    2) all previous regions have been closed or joined so only this region can fail</span>
          <span class="slc">#    3) this region must be good since there can never be only 1 region that is nuot</span>
          <span class="slc">#       a multiple of five</span>
          <span class="slc"># this rule only applies when filling normally, so we ignore the rule if we are &quot;slotting&quot;</span>
          <span class="slc"># in pieces to see what configurations work for them (the only other time this algorithm is used).</span>
          <span class="kwa">return false if</span> (collector[<span class="num">2</span>] == <span class="num">0b11111</span> &amp;&amp; !slotting<span class="opt">)</span>
          collector[<span class="num">0</span>] = converter[collector[<span class="num">2</span>]]
          collector[<span class="num">2</span>] = <span class="num">0</span>
        <span class="kwa">end</span>
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    
    <span class="slc"># get rid of all the empty converters for the next round</span>
    collectors.compact!
  <span class="kwa">end</span>
  <span class="kwa">return false if</span> (collectors.length &lt;= <span class="num">1</span><span class="opt">)</span> <span class="slc"># 1 collector or less and the region is fine</span>
  collectors.any? { | collector | (collector[1] % 5) != 0 } <span class="slc"># more than 1 and we test them all for bad size</span>
<span class="kwa">end</span>
  
<span class="slc"># creates a region given a row mask.  see prunable for what a &quot;region&quot; is</span>
<span class="kwa">def</span> <span class="kwd">create_regions</span>( value <span class="opt">)</span>
  regions = []
  cur_region = <span class="num">0</span>
  <span class="num">5</span>.times <span class="kwa">do</span> | bit |
    <span class="kwa">if</span> (value[bit] == <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
      cur_region |= <span class="num">1</span> &lt;&lt; bit
    <span class="kwa">else</span>
      <span class="kwa">if</span> (cur_region != <span class="num">0</span> <span class="opt">)</span> <span class="kwa">then</span>
        regions.<span class="kwd">push</span>( cur_region<span class="opt">)</span>
        cur_region = <span class="num">0</span>;
      <span class="kwa">end</span>
    <span class="kwa">end</span>
  <span class="kwa">end</span>
  regions.<span class="kwd">push</span>(cur_region<span class="opt">)</span> <span class="kwa">if</span> (cur_region != <span class="num">0</span><span class="opt">)</span>
  regions
<span class="kwa">end</span>

<span class="slc"># find up to the counted number of solutions (or all solutions) and prints the final result</span>
<span class="kwa">def</span> find_all
  <span class="kwd">find_top</span>( <span class="num">1</span><span class="opt">)</span>
  <span class="kwd">find_top</span>( <span class="num">0</span><span class="opt">)</span>
  print_results
<span class="kwa">end</span>

<span class="slc"># show the board</span>
<span class="kwa">def</span> print_results
  print <span class="str">&quot;</span><span class="ipl">#{&#64;boards_found}</span> <span class="str">solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span>
  <span class="kwd">print_full_board</span>( <span class="kwb">&#64;min_board</span><span class="opt">)</span>
  print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
  <span class="kwd">print_full_board</span>( <span class="kwb">&#64;max_board</span><span class="opt">)</span>
  print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
<span class="kwa">end</span>

<span class="slc"># finds solutions.  This special version of the main function is only used for the top level</span>
<span class="slc"># the reason for it is basically to force a particular ordering on how the rotations are tested for</span>
<span class="slc"># the first piece.  It is called twice, first looking for placements of the odd rotations and then </span>
<span class="slc"># looking for placements of the even locations.</span>
<span class="slc"># </span>
<span class="slc"># WHY?</span>
<span class="slc">#   Since any found solution has an inverse we want to maximize finding solutions that are not already found </span>
<span class="slc">#   as an inverse.  The inverse will ALWAYS be 3 one of the piece configurations that is exactly 3 rotations away </span>
<span class="slc">#   (an odd number).  Checking even vs odd then produces a higher probability of finding more pieces earlier </span>
<span class="slc">#   in the cycle.  We still need to keep checking all the permutations, but our probability of finding one will</span>
<span class="slc">#   diminsh over time.  Since we are TOLD how many to search for this lets us exit before checking all pieces</span>
<span class="slc">#   this bennifit is very great when seeking small numbers of solutions and is 0 when looking for more than the </span>
<span class="slc">#   maximum number </span>
<span class="kwa">def</span> <span class="kwd">find_top</span>( rotation_skip<span class="opt">)</span> 
  board = blank_board
  (<span class="kwb">&#64;pieces</span>.length-1<span class="opt">)</span>.times <span class="kwa">do</span>
    piece = <span class="kwb">&#64;pieces</span>.shift
    piece.masks[<span class="num">0</span>].each <span class="kwa">do</span> | mask, imask, cmask |
      <span class="kwa">if</span> ((rotation_skip += <span class="num">1</span><span class="opt">)</span> % <span class="num">2</span> == <span class="num">0</span><span class="opt">)</span> <span class="kwa">then</span>
        piece.placed = mask
        <span class="kwd">find</span>( <span class="num">1</span>, <span class="num">1</span>, board | mask<span class="opt">)</span> 
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    <span class="kwb">&#64;pieces</span>.<span class="kwd">push</span>(piece<span class="opt">)</span>
  <span class="kwa">end</span>
  piece = <span class="kwb">&#64;pieces</span>.shift
  <span class="kwb">&#64;pieces</span>.<span class="kwd">push</span>(piece<span class="opt">)</span>
<span class="kwa">end</span>

<span class="slc"># the normail find routine, iterates through the available pieces, checks all rotations at the current location</span>
<span class="slc"># and adds any boards found.  depth is acheived via recursion.  the overall approach is described </span>
<span class="slc"># here: http://www-128.ibm.com/developerworks/java/library/j-javaopt/</span>
<span class="slc"># parameters:</span>
<span class="slc">#  start_location -- where to start looking for place for the next piece at</span>
<span class="slc">#  placed -- number of pieces placed</span>
<span class="slc">#  board -- current state of the board</span>
<span class="slc">#</span>
<span class="slc"># see in-code comments</span>
<span class="kwa">def</span> <span class="kwd">find</span>( start_location, placed, board<span class="opt">)</span> 
  <span class="slc"># find the next location to place a piece by looking for an empty bit</span>
  <span class="kwa">while</span> board[start_location] == <span class="num">1</span>
    start_location += <span class="num">1</span> 
  <span class="kwa">end</span>
  
  <span class="kwb">&#64;pieces</span>.length.times <span class="kwa">do</span>
    piece = <span class="kwb">&#64;pieces</span>.shift
    piece.masks[start_location].each <span class="kwa">do</span> | mask, imask, cmask |
      <span class="kwa">if</span> ( board &amp; cmask == imask<span class="opt">)</span> <span class="kwa">then</span>
        piece.placed = mask
        <span class="kwa">if</span> (placed == <span class="num">9</span><span class="opt">)</span> <span class="kwa">then</span>
          add_board
        <span class="kwa">else</span>
          <span class="kwd">find</span>( start_location + <span class="num">1</span>, placed + <span class="num">1</span>, board | mask<span class="opt">)</span> 
        <span class="kwa">end</span>
      <span class="kwa">end</span>
    <span class="kwa">end</span>
    <span class="kwb">&#64;pieces</span>.<span class="kwd">push</span>(piece<span class="opt">)</span>
  <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="slc"># print the board</span>
<span class="kwa">def</span> <span class="kwd">print_full_board</span>( board_string<span class="opt">)</span>
  <span class="num">10</span>.times <span class="kwa">do</span> | row |
    print <span class="str">&quot; &quot;</span> <span class="kwa">if</span> (row % <span class="num">2</span> == <span class="num">1</span><span class="opt">)</span> 
    <span class="num">5</span>.times <span class="kwa">do</span> | col |
      print <span class="str">&quot;</span><span class="ipl">#{board_string[row*5 + col,1]}</span> <span class="str">&quot;</span>
    <span class="kwa">end</span>
    print <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
  <span class="kwa">end</span>
<span class="kwa">end</span>

<span class="slc"># when a board is found we &quot;draw it&quot; into a string and then flip that string, adding both to</span>
<span class="slc"># the list (hash) of solutions if they are unique.  </span>
<span class="kwa">def</span> add_board
  board_string = <span class="str">&quot;99999999999999999999999999999999999999999999999999&quot;</span>
  <span class="kwb">&#64;all_pieces</span>.each {  | piece | piece.fill_string( board_string ) }
  <span class="kwd">save</span>( board_string<span class="opt">)</span>
  <span class="kwd">save</span>( board_string.reverse<span class="opt">)</span>
<span class="kwa">end</span>

<span class="slc"># adds a board string to the list (if new) and updates the current best/worst board</span>
<span class="kwa">def</span> <span class="kwd">save</span>( board_string<span class="opt">)</span>
  <span class="kwa">if</span> (<span class="kwb">&#64;all_boards</span>[board_string] == <span class="kwa">nil</span><span class="opt">)</span> <span class="kwa">then</span>
    <span class="kwb">&#64;min_board</span> = board_string <span class="kwa">if</span> (board_string &lt; <span class="kwb">&#64;min_board</span><span class="opt">)</span>
    <span class="kwb">&#64;max_board</span> = board_string <span class="kwa">if</span> (board_string &gt; <span class="kwb">&#64;max_board</span><span class="opt">)</span>
    <span class="kwb">&#64;all_boards</span>.<span class="kwd">store</span>(board_string,<span class="kwa">true</span><span class="opt">)</span>
    <span class="kwb">&#64;boards_found</span> += <span class="num">1</span>

    <span class="slc"># the exit motif is a time saver.  Ideally the function should return, but those tests</span>
    <span class="slc"># take noticable time (performance).</span>
    <span class="kwa">if</span> (<span class="kwb">&#64;boards_found</span> == <span class="kwb">&#64;stop_count</span><span class="opt">)</span> <span class="kwa">then</span>
      print_results
      <span class="kwd">exit</span>(<span class="num">0</span><span class="opt">)</span>
    <span class="kwa">end</span>
  <span class="kwa">end</span>
<span class="kwa">end</span>


<span class="slc">##</span>
<span class="slc">## MAIN BODY :)</span>
<span class="slc">##</span>
create_collector_support
<span class="kwb">&#64;pieces</span> = [ 
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:nw</span>, <span class="kwc">:ne</span>, <span class="kwc">:east</span>, <span class="kwc">:east</span> ], <span class="num">2</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:ne</span>, <span class="kwc">:se</span>, <span class="kwc">:east</span>, <span class="kwc">:ne</span> ], <span class="num">7</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:ne</span>, <span class="kwc">:east</span>, <span class="kwc">:ne</span>, <span class="kwc">:nw</span> ], <span class="num">1</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:east</span>, <span class="kwc">:sw</span>, <span class="kwc">:sw</span>, <span class="kwc">:se</span> ], <span class="num">6</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:east</span>, <span class="kwc">:ne</span>, <span class="kwc">:se</span>, <span class="kwc">:ne</span> ], <span class="num">5</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:east</span>, <span class="kwc">:east</span>, <span class="kwc">:east</span>, <span class="kwc">:se</span> ], <span class="num">0</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:ne</span>, <span class="kwc">:nw</span>, <span class="kwc">:se</span>, <span class="kwc">:east</span>, <span class="kwc">:se</span> ], <span class="num">4</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:se</span>, <span class="kwc">:se</span>, <span class="kwc">:se</span>, <span class="kwc">:west</span> ], <span class="num">9</span><span class="opt">)</span>, 
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:se</span>, <span class="kwc">:se</span>, <span class="kwc">:east</span>, <span class="kwc">:se</span> ], <span class="num">8</span><span class="opt">)</span>,
  Piece.<span class="kwd">new</span>( [ <span class="kwc">:east</span>, <span class="kwc">:east</span>, <span class="kwc">:sw</span>, <span class="kwc">:se</span> ], <span class="num">3</span><span class="opt">)</span>
  ];
  
<span class="kwb">&#64;all_pieces</span> = Array.<span class="kwd">new</span>( <span class="kwb">&#64;pieces</span><span class="opt">)</span>

<span class="kwb">&#64;min_board</span> = <span class="str">&quot;99999999999999999999999999999999999999999999999999&quot;</span>
<span class="kwb">&#64;max_board</span> = <span class="str">&quot;00000000000000000000000000000000000000000000000000&quot;</span>
<span class="kwb">&#64;stop_count</span> = <span class="kwc">ARGV</span>[<span class="num">0</span>].to_i || <span class="num">2089</span>
<span class="kwb">&#64;all_boards</span> = {}
<span class="kwb">&#64;boards_found</span> = <span class="num">0</span>

find_all <span class="slc">######## DO IT!!!</span>

