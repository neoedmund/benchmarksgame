<span class="com">/* The Computer Language Benchmarks Game</span>
<span class="com"> * http://benchmarksgame.alioth.debian.org/</span>
<span class="com"> *</span>
<span class="com"> * contributed by The Go Authors.</span>
<span class="com"> * based on meteor-contest.c by Christian Vosteen</span>
<span class="com"> * flag.Arg hack by Isaac Gouy</span>
<span class="com"> */</span>

<span class="kwa">package</span> main

<span class="kwa">import</span> (
   <span class="str">&quot;flag&quot;</span>
   <span class="str">&quot;fmt&quot;</span>
   <span class="str">&quot;strconv&quot;</span>
)

<span class="kwa">var</span> max_solutions = <span class="num">0</span>


<span class="kwa">func</span> <span class="kwd">boolInt</span>(b <span class="kwb">bool</span>) <span class="kwb">int8</span> {
   <span class="kwa">if</span> b {
      <span class="kwa">return</span> <span class="num">1</span>
   }
   <span class="kwa">return</span> <span class="num">0</span>
}

<span class="com">/* The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="com"> * maximum speed the board will be implemented as     . . . . .</span>
<span class="com"> * 50 bits, which will fit into a 64 bit long long   . . . . .</span>
<span class="com"> * int.                                               . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> * I will represent 0's as empty cells and 1's        . . . . .</span>
<span class="com"> * as full cells.                                    . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> *                                                   . . . . .</span>
<span class="com"> *                                                    . . . . .</span>
<span class="com"> */</span>

<span class="kwa">var</span> board <span class="kwb">uint64</span> = <span class="num">0xFFFC000000000000</span>

<span class="com">/* The puzzle pieces must be specified by the path followed</span>
<span class="com"> * from one end to the other along 12 hexagonal directions.</span>
<span class="com"> *</span>
<span class="com"> *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="com"> *</span>
<span class="com"> *  O O O O    O   O O   O O O     O O O     O   O</span>
<span class="com"> *         O    O O           O       O       O O</span>
<span class="com"> *                           O         O         O</span>
<span class="com"> *</span>
<span class="com"> *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="com"> *</span>
<span class="com"> *    O O O     O O       O O     O O        O O O O</span>
<span class="com"> *       O O       O O       O       O O O        O</span>
<span class="com"> *                  O       O O</span>
<span class="com"> *</span>
<span class="com"> * I had to make it 12 directions because I wanted all of the</span>
<span class="com"> * piece definitions to fit into the same size arrays.  It is</span>
<span class="com"> * not possible to define piece 4 in terms of the 6 cardinal</span>
<span class="com"> * directions in 4 moves.</span>
<span class="com"> */</span>

<span class="kwa">const</span> (
   E = <span class="kwb">iota</span>
   ESE
   SE
   S
   SW
   WSW
   W
   WNW
   NW
   N
   NE
   ENE
   PIVOT
)

<span class="kwa">var</span> piece_def = [<span class="num">10</span>][<span class="num">4</span>]<span class="kwb">int8</span>{
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, E, E, SE},
   [<span class="num">4</span>]<span class="kwb">int8</span>{SE, E, NE, E},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, E, SE, SW},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, E, SW, SE},
   [<span class="num">4</span>]<span class="kwb">int8</span>{SE, E, NE, S},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, E, SW, E},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, SE, SE, NE},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, SE, SE, W},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, SE, E, E},
   [<span class="num">4</span>]<span class="kwb">int8</span>{E, E, E, SW},
}


<span class="com">/* To minimize the amount of work done in the recursive solve function below,</span>
<span class="com"> * I'm going to allocate enough space for all legal rotations of each piece</span>
<span class="com"> * at each position on the board. That's 10 pieces x 50 board positions x</span>
<span class="com"> * 12 rotations.  However, not all 12 rotations will fit on every cell, so</span>
<span class="com"> * I'll have to keep count of the actual number that do.</span>
<span class="com"> * The pieces are going to be unsigned long long ints just like the board so</span>
<span class="com"> * they can be bitwise-anded with the board to determine if they fit.</span>
<span class="com"> * I'm also going to record the next possible open cell for each piece and</span>
<span class="com"> * location to reduce the burden on the solve function.</span>
<span class="com"> */</span>
<span class="kwa">var</span> (
   pieces       [<span class="num">10</span>][<span class="num">50</span>][<span class="num">12</span>]<span class="kwb">uint64</span>
   piece_counts [<span class="num">10</span>][<span class="num">50</span>]<span class="kwb">int</span>
   next_cell    [<span class="num">10</span>][<span class="num">50</span>][<span class="num">12</span>]<span class="kwb">int8</span>
)

<span class="com">/* Returns the direction rotated 60 degrees clockwise */</span>
<span class="kwa">func</span> <span class="kwd">rotate</span>(dir <span class="kwb">int8</span>) <span class="kwb">int8</span> { <span class="kwa">return</span> (dir + <span class="num">2</span>) % PIVOT }

<span class="com">/* Returns the direction flipped on the horizontal axis */</span>
<span class="kwa">func</span> <span class="kwd">flip</span>(dir <span class="kwb">int8</span>) <span class="kwb">int8</span> { <span class="kwa">return</span> (PIVOT - dir) % PIVOT }


<span class="com">/* Returns the new cell index from the specified cell in the</span>
<span class="com"> * specified direction.  The index is only valid if the</span>
<span class="com"> * starting cell and direction have been checked by the</span>
<span class="com"> * out_of_bounds function first.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">shift</span>(cell, dir <span class="kwb">int8</span>) <span class="kwb">int8</span> {
   <span class="kwa">switch</span> dir {
   <span class="kwa">case</span> E:
      <span class="kwa">return</span> cell + <span class="num">1</span>
   <span class="kwa">case</span> ESE:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell + <span class="num">7</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell + <span class="num">6</span>
      }
   <span class="kwa">case</span> SE:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell + <span class="num">6</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell + <span class="num">5</span>
      }
   <span class="kwa">case</span> S:
      <span class="kwa">return</span> cell + <span class="num">10</span>
   <span class="kwa">case</span> SW:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell + <span class="num">5</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell + <span class="num">4</span>
      }
   <span class="kwa">case</span> WSW:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell + <span class="num">4</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell + <span class="num">3</span>
      }
   <span class="kwa">case</span> W:
      <span class="kwa">return</span> cell - <span class="num">1</span>
   <span class="kwa">case</span> WNW:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell - <span class="num">6</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell - <span class="num">7</span>
      }
   <span class="kwa">case</span> NW:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell - <span class="num">5</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell - <span class="num">6</span>
      }
   <span class="kwa">case</span> N:
      <span class="kwa">return</span> cell - <span class="num">10</span>
   <span class="kwa">case</span> NE:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell - <span class="num">4</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell - <span class="num">5</span>
      }
   <span class="kwa">case</span> ENE:
      <span class="kwa">if</span> ((cell / <span class="num">5</span>) % <span class="num">2</span>) != <span class="num">0</span> {
         <span class="kwa">return</span> cell - <span class="num">3</span>
      } <span class="kwa">else</span> {
         <span class="kwa">return</span> cell - <span class="num">4</span>
      }
   }
   <span class="kwa">return</span> cell
}

<span class="com">/* Returns wether the specified cell and direction will land outside</span>
<span class="com"> * of the board.  Used to determine if a piece is at a legal board</span>
<span class="com"> * location or not.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">out_of_bounds</span>(cell, dir <span class="kwb">int8</span>) <span class="kwb">bool</span> {
   <span class="kwa">switch</span> dir {
   <span class="kwa">case</span> E:
      <span class="kwa">return</span> cell%5 == <span class="num">4</span>
   <span class="kwa">case</span> ESE:
      i := cell % <span class="num">10</span>
      <span class="kwa">return</span> i == <span class="num">4</span> || i == <span class="num">8</span> || i == <span class="num">9</span> || cell &gt;= <span class="num">45</span>
   <span class="kwa">case</span> SE:
      <span class="kwa">return</span> cell%10 == <span class="num">9</span> || cell &gt;= <span class="num">45</span>
   <span class="kwa">case</span> S:
      <span class="kwa">return</span> cell &gt;= <span class="num">40</span>
   <span class="kwa">case</span> SW:
      <span class="kwa">return</span> cell%10 == <span class="num">0</span> || cell &gt;= <span class="num">45</span>
   <span class="kwa">case</span> WSW:
      i := cell % <span class="num">10</span>
      <span class="kwa">return</span> i == <span class="num">0</span> || i == <span class="num">1</span> || i == <span class="num">5</span> || cell &gt;= <span class="num">45</span>
   <span class="kwa">case</span> W:
      <span class="kwa">return</span> cell%5 == <span class="num">0</span>
   <span class="kwa">case</span> WNW:
      i := cell % <span class="num">10</span>
      <span class="kwa">return</span> i == <span class="num">0</span> || i == <span class="num">1</span> || i == <span class="num">5</span> || cell &lt; <span class="num">5</span>
   <span class="kwa">case</span> NW:
      <span class="kwa">return</span> cell%10 == <span class="num">0</span> || cell &lt; <span class="num">5</span>
   <span class="kwa">case</span> N:
      <span class="kwa">return</span> cell &lt; <span class="num">10</span>
   <span class="kwa">case</span> NE:
      <span class="kwa">return</span> cell%10 == <span class="num">9</span> || cell &lt; <span class="num">5</span>
   <span class="kwa">case</span> ENE:
      i := cell % <span class="num">10</span>
      <span class="kwa">return</span> i == <span class="num">4</span> || i == <span class="num">8</span> || i == <span class="num">9</span> || cell &lt; <span class="num">5</span>
   }
   <span class="kwa">return</span> <span class="kwb">false</span>
}

<span class="com">/* Rotate a piece 60 degrees clockwise */</span>
<span class="kwa">func</span> <span class="kwd">rotate_piece</span>(piece <span class="kwb">int</span>) {
   <span class="kwa">for</span> i := <span class="num">0</span>; i &lt; <span class="num">4</span>; i++ {
      piece_def[piece][i] = <span class="kwd">rotate</span>(piece_def[piece][i])
   }
}

<span class="com">/* Flip a piece along the horizontal axis */</span>
<span class="kwa">func</span> <span class="kwd">flip_piece</span>(piece <span class="kwb">int</span>) {
   <span class="kwa">for</span> i := <span class="num">0</span>; i &lt; <span class="num">4</span>; i++ {
      piece_def[piece][i] = <span class="kwd">flip</span>(piece_def[piece][i])
   }
}

<span class="com">/* Convenience function to quickly calculate all of the indices for a piece */</span>
<span class="kwa">func</span> <span class="kwd">calc_cell_indices</span>(cell []<span class="kwb">int8</span>, piece <span class="kwb">int</span>, index <span class="kwb">int8</span>) {
   cell[<span class="num">0</span>] = index
   <span class="kwa">for</span> i := <span class="num">1</span>; i &lt; <span class="num">5</span>; i++ {
      cell[i] = <span class="kwd">shift</span>(cell[i-<span class="num">1</span>], piece_def[piece][i-<span class="num">1</span>])
   }
}

<span class="com">/* Convenience function to quickly calculate if a piece fits on the board */</span>
<span class="kwa">func</span> <span class="kwd">cells_fit_on_board</span>(cell []<span class="kwb">int8</span>, piece <span class="kwb">int</span>) <span class="kwb">bool</span> {
   <span class="kwa">return</span> !<span class="kwd">out_of_bounds</span>(cell[<span class="num">0</span>], piece_def[piece][<span class="num">0</span>]) &amp;&amp;
      !<span class="kwd">out_of_bounds</span>(cell[<span class="num">1</span>], piece_def[piece][<span class="num">1</span>]) &amp;&amp;
      !<span class="kwd">out_of_bounds</span>(cell[<span class="num">2</span>], piece_def[piece][<span class="num">2</span>]) &amp;&amp;
      !<span class="kwd">out_of_bounds</span>(cell[<span class="num">3</span>], piece_def[piece][<span class="num">3</span>])
}

<span class="com">/* Returns the lowest index of the cells of a piece.</span>
<span class="com"> * I use the lowest index that a piece occupies as the index for looking up</span>
<span class="com"> * the piece in the solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">minimum_of_cells</span>(cell []<span class="kwb">int8</span>) <span class="kwb">int8</span> {
   minimum := cell[<span class="num">0</span>]
   <span class="kwa">for</span> i := <span class="num">1</span>; i &lt; <span class="num">5</span>; i++ {
      <span class="kwa">if</span> cell[i] &lt; minimum {
         minimum = cell[i]
      }
   }
   <span class="kwa">return</span> minimum
}

<span class="com">/* Calculate the lowest possible open cell if the piece is placed on the board.</span>
<span class="com"> * Used to later reduce the amount of time searching for open cells in the</span>
<span class="com"> * solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">first_empty_cell</span>(cell []<span class="kwb">int8</span>, minimum <span class="kwb">int8</span>) <span class="kwb">int8</span> {
   first_empty := minimum
   <span class="kwa">for</span> first_empty == cell[<span class="num">0</span>] || first_empty == cell[<span class="num">1</span>] ||
      first_empty == cell[<span class="num">2</span>] || first_empty == cell[<span class="num">3</span>] ||
      first_empty == cell[<span class="num">4</span>] {
      first_empty++
   }
   <span class="kwa">return</span> first_empty
}

<span class="com">/* Generate the unsigned long long int that will later be anded with the</span>
<span class="com"> * board to determine if it fits.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">bitmask_from_cells</span>(cell []<span class="kwb">int8</span>) <span class="kwb">uint64</span> {
   <span class="kwa">var</span> piece_mask <span class="kwb">uint64</span>
   <span class="kwa">for</span> i := <span class="num">0</span>; i &lt; <span class="num">5</span>; i++ {
      piece_mask |= <span class="num">1</span> &lt;&lt; <span class="kwb">uint</span>(cell[i])
   }
   <span class="kwa">return</span> piece_mask
}

<span class="com">/* Record the piece and other important information in arrays that will</span>
<span class="com"> * later be used by the solve function.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">record_piece</span>(piece <span class="kwb">int</span>, minimum <span class="kwb">int8</span>, first_empty <span class="kwb">int8</span>, piece_mask <span class="kwb">uint64</span>) {
   pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask
   next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty
   piece_counts[piece][minimum]++
}


<span class="com">/* Fill the entire board going cell by cell.  If any cells are &quot;trapped&quot;</span>
<span class="com"> * they will be left alone.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">fill_contiguous_space</span>(board []<span class="kwb">int8</span>, index <span class="kwb">int8</span>) {
   <span class="kwa">if</span> board[index] == <span class="num">1</span> {
      <span class="kwa">return</span>
   }
   board[index] = <span class="num">1</span>
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, E) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, E))
   }
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, SE) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, SE))
   }
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, SW) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, SW))
   }
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, W) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, W))
   }
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, NW) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, NW))
   }
   <span class="kwa">if</span> !<span class="kwd">out_of_bounds</span>(index, NE) {
      <span class="kwd">fill_contiguous_space</span>(board, <span class="kwd">shift</span>(index, NE))
   }
}


<span class="com">/* To thin the number of pieces, I calculate if any of them trap any empty</span>
<span class="com"> * cells at the edges.  There are only a handful of exceptions where the</span>
<span class="com"> * the board can be solved with the trapped cells.  For example:  piece 8 can</span>
<span class="com"> * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0</span>
<span class="com"> * can split the board in half where both halves are viable.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">has_island</span>(cell []<span class="kwb">int8</span>, piece <span class="kwb">int</span>) <span class="kwb">bool</span> {
   temp_board := <span class="kwb">make</span>([]<span class="kwb">int8</span>, <span class="num">50</span>)
   <span class="kwa">var</span> i <span class="kwb">int</span>
   <span class="kwa">for</span> i = <span class="num">0</span>; i &lt; <span class="num">5</span>; i++ {
      temp_board[cell[i]] = <span class="num">1</span>
   }
   i = <span class="num">49</span>
   <span class="kwa">for</span> temp_board[i] == <span class="num">1</span> {
      i--
   }
   <span class="kwd">fill_contiguous_space</span>(temp_board, <span class="kwb">int8</span>(i))
   c := <span class="num">0</span>
   <span class="kwa">for</span> i = <span class="num">0</span>; i &lt; <span class="num">50</span>; i++ {
      <span class="kwa">if</span> temp_board[i] == <span class="num">0</span> {
         c++
      }
   }
   <span class="kwa">if</span> c == <span class="num">0</span> || (c == <span class="num">5</span> &amp;&amp; piece == <span class="num">8</span>) || (c == <span class="num">40</span> &amp;&amp; piece == <span class="num">8</span>) ||
      (c%5 == <span class="num">0</span> &amp;&amp; piece == <span class="num">0</span>) {
      <span class="kwa">return</span> <span class="kwb">false</span>
   }
   <span class="kwa">return</span> <span class="kwb">true</span>
}


<span class="com">/* Calculate all six rotations of the specified piece at the specified index.</span>
<span class="com"> * We calculate only half of piece 3's rotations.  This is because any solution</span>
<span class="com"> * found has an identical solution rotated 180 degrees.  Thus we can reduce the</span>
<span class="com"> * number of attempted pieces in the solve algorithm by not including the 180-</span>
<span class="com"> * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave</span>
<span class="com"> * me the best time ;)</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">calc_six_rotations</span>(piece, index <span class="kwb">int</span>) {
   cell := <span class="kwb">make</span>([]<span class="kwb">int8</span>, <span class="num">5</span>)
   <span class="kwa">for</span> rotation := <span class="num">0</span>; rotation &lt; <span class="num">6</span>; rotation++ {
      <span class="kwa">if</span> piece != <span class="num">3</span> || rotation &lt; <span class="num">3</span> {
         <span class="kwd">calc_cell_indices</span>(cell, piece, <span class="kwb">int8</span>(index))
         <span class="kwa">if</span> <span class="kwd">cells_fit_on_board</span>(cell, piece) &amp;&amp; !<span class="kwd">has_island</span>(cell, piece) {
            minimum := <span class="kwd">minimum_of_cells</span>(cell)
            first_empty := <span class="kwd">first_empty_cell</span>(cell, minimum)
            piece_mask := <span class="kwd">bitmask_from_cells</span>(cell)
            <span class="kwd">record_piece</span>(piece, minimum, first_empty, piece_mask)
         }
      }
      <span class="kwd">rotate_piece</span>(piece)
   }
}

<span class="com">/* Calculate every legal rotation for each piece at each board location. */</span>
<span class="kwa">func</span> <span class="kwd">calc_pieces</span>() {
   <span class="kwa">for</span> piece := <span class="num">0</span>; piece &lt; <span class="num">10</span>; piece++ {
      <span class="kwa">for</span> index := <span class="num">0</span>; index &lt; <span class="num">50</span>; index++ {
         <span class="kwd">calc_six_rotations</span>(piece, index)
         <span class="kwd">flip_piece</span>(piece)
         <span class="kwd">calc_six_rotations</span>(piece, index)
      }
   }
}


<span class="com">/* Calculate all 32 possible states for a 5-bit row and all rows that will</span>
<span class="com"> * create islands that follow any of the 32 possible rows.  These pre-</span>
<span class="com"> * calculated 5-bit rows will be used to find islands in a partially solved</span>
<span class="com"> * board in the solve function.</span>
<span class="com"> */</span>
<span class="kwa">const</span> (
   ROW_MASK    = <span class="num">0x1F</span>
   TRIPLE_MASK = <span class="num">0x7FFF</span>
)

<span class="kwa">var</span> (
   all_rows = [<span class="num">32</span>]<span class="kwb">int8</span>{<span class="num">0</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>, <span class="num">8</span>, <span class="num">9</span>, <span class="num">10</span>, <span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>, <span class="num">15</span>, <span class="num">16</span>,
      <span class="num">17</span>, <span class="num">18</span>, <span class="num">19</span>, <span class="num">20</span>, <span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>, <span class="num">26</span>, <span class="num">27</span>, <span class="num">28</span>, <span class="num">29</span>, <span class="num">30</span>, <span class="num">31</span>,
   }
   bad_even_rows   [<span class="num">32</span>][<span class="num">32</span>]<span class="kwb">int8</span>
   bad_odd_rows    [<span class="num">32</span>][<span class="num">32</span>]<span class="kwb">int8</span>
   bad_even_triple [<span class="num">32768</span>]<span class="kwb">int8</span>
   bad_odd_triple  [<span class="num">32768</span>]<span class="kwb">int8</span>
)

<span class="kwa">func</span> <span class="kwd">rows_bad</span>(row1, row2 <span class="kwb">int8</span>, even <span class="kwb">bool</span>) <span class="kwb">int8</span> {
   <span class="com">/* even is referring to row1 */</span>
   <span class="kwa">var</span> row2_shift <span class="kwb">int8</span>
   <span class="com">/* Test for blockages at same index and shifted index */</span>
   <span class="kwa">if</span> even {
      row2_shift = ((row2 &lt;&lt; <span class="num">1</span>) &amp; ROW_MASK) | <span class="num">0x01</span>
   } <span class="kwa">else</span> {
      row2_shift = (row2 &gt;&gt; <span class="num">1</span>) | <span class="num">0x10</span>
   }
   block := ((row1 ^ row2) &amp; row2) &amp; ((row1 ^ row2_shift) &amp; row2_shift)
   <span class="com">/* Test for groups of 0's */</span>
   in_zeroes := <span class="kwb">false</span>
   group_okay := <span class="kwb">false</span>
   <span class="kwa">for</span> i := <span class="kwb">uint8</span>(<span class="num">0</span>); i &lt; <span class="num">5</span>; i++ {
      <span class="kwa">if</span> row1&amp;(<span class="num">1</span>&lt;&lt;i) != <span class="num">0</span> {
         <span class="kwa">if</span> in_zeroes {
            <span class="kwa">if</span> !group_okay {
               <span class="kwa">return</span> <span class="num">1</span>
            }
            in_zeroes = <span class="kwb">false</span>
            group_okay = <span class="kwb">false</span>
         }
      } <span class="kwa">else</span> {
         <span class="kwa">if</span> !in_zeroes {
            in_zeroes = <span class="kwb">true</span>
         }
         <span class="kwa">if</span> (block &amp; (<span class="num">1</span> &lt;&lt; i)) == <span class="num">0</span> {
            group_okay = <span class="kwb">true</span>
         }
      }
   }
   <span class="kwa">if</span> in_zeroes {
      <span class="kwa">return</span> <span class="kwd">boolInt</span>(!group_okay)
   }
   <span class="kwa">return</span> <span class="num">0</span>
}

<span class="com">/* Check for cases where three rows checked sequentially cause a false</span>
<span class="com"> * positive.  One scenario is when 5 cells may be surrounded where piece 5</span>
<span class="com"> * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.</span>
<span class="com"> */</span>
<span class="kwa">func</span> <span class="kwd">triple_is_okay</span>(row1, row2, row3 <span class="kwb">int</span>, even <span class="kwb">bool</span>) <span class="kwb">bool</span> {
   <span class="kwa">if</span> even {
      <span class="com">/* There are four cases:</span>
<span class="com">       * row1: 00011  00001  11001  10101</span>
<span class="com">       * row2: 01011  00101  10001  10001</span>
<span class="com">       * row3: 011??  00110  ?????  ?????</span>
<span class="com">       */</span>
      <span class="kwa">return</span> ((row1 == <span class="num">0x03</span>) &amp;&amp; (row2 == <span class="num">0x0B</span>) &amp;&amp; ((row3 &amp; <span class="num">0x1C</span>) == <span class="num">0x0C</span>)) ||
         ((row1 == <span class="num">0x01</span>) &amp;&amp; (row2 == <span class="num">0x05</span>) &amp;&amp; (row3 == <span class="num">0x06</span>)) ||
         ((row1 == <span class="num">0x19</span>) &amp;&amp; (row2 == <span class="num">0x11</span>)) ||
         ((row1 == <span class="num">0x15</span>) &amp;&amp; (row2 == <span class="num">0x11</span>))
   }
   <span class="com">/* There are two cases:</span>
<span class="com">    * row1: 10011  10101</span>
<span class="com">    * row2: 10001  10001</span>
<span class="com">    * row3: ?????  ?????</span>
<span class="com">    */</span>
   <span class="kwa">return</span> ((row1 == <span class="num">0x13</span>) &amp;&amp; (row2 == <span class="num">0x11</span>)) ||
      ((row1 == <span class="num">0x15</span>) &amp;&amp; (row2 == <span class="num">0x11</span>))
}

<span class="kwa">func</span> <span class="kwd">calc_rows</span>() {
   <span class="kwa">for</span> row1 := <span class="kwb">int8</span>(<span class="num">0</span>); row1 &lt; <span class="num">32</span>; row1++ {
      <span class="kwa">for</span> row2 := <span class="kwb">int8</span>(<span class="num">0</span>); row2 &lt; <span class="num">32</span>; row2++ {
         bad_even_rows[row1][row2] = <span class="kwd">rows_bad</span>(row1, row2, <span class="kwb">true</span>)
         bad_odd_rows[row1][row2] = <span class="kwd">rows_bad</span>(row1, row2, <span class="kwb">false</span>)
      }
   }
   <span class="kwa">for</span> row1 := <span class="num">0</span>; row1 &lt; <span class="num">32</span>; row1++ {
      <span class="kwa">for</span> row2 := <span class="num">0</span>; row2 &lt; <span class="num">32</span>; row2++ {
         <span class="kwa">for</span> row3 := <span class="num">0</span>; row3 &lt; <span class="num">32</span>; row3++ {
            result1 := bad_even_rows[row1][row2]
            result2 := bad_odd_rows[row2][row3]
            <span class="kwa">if</span> result1 == <span class="num">0</span> &amp;&amp; result2 != <span class="num">0</span> &amp;&amp; <span class="kwd">triple_is_okay</span>(row1, row2, row3, <span class="kwb">true</span>) {
               bad_even_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = <span class="num">0</span>
            } <span class="kwa">else</span> {
               bad_even_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = <span class="kwd">boolInt</span>(result1 != <span class="num">0</span> || result2 != <span class="num">0</span>)
            }

            result1 = bad_odd_rows[row1][row2]
            result2 = bad_even_rows[row2][row3]
            <span class="kwa">if</span> result1 == <span class="num">0</span> &amp;&amp; result2 != <span class="num">0</span> &amp;&amp; <span class="kwd">triple_is_okay</span>(row1, row2, row3, <span class="kwb">false</span>) {
               bad_odd_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = <span class="num">0</span>
            } <span class="kwa">else</span> {
               bad_odd_triple[row1+(row2*<span class="num">32</span>)+(row3*<span class="num">1024</span>)] = <span class="kwd">boolInt</span>(result1 != <span class="num">0</span> || result2 != <span class="num">0</span>)
            }
         }
      }
   }
}


<span class="com">/* Calculate islands while solving the board.</span>
<span class="com">*/</span>
<span class="kwa">func</span> <span class="kwd">boardHasIslands</span>(cell <span class="kwb">int8</span>) <span class="kwb">int8</span> {
   <span class="com">/* Too low on board, don't bother checking */</span>
   <span class="kwa">if</span> cell &gt;= <span class="num">40</span> {
      <span class="kwa">return</span> <span class="num">0</span>
   }
   current_triple := (board &gt;&gt; <span class="kwb">uint</span>((cell/<span class="num">5</span>)*<span class="num">5</span>)) &amp; TRIPLE_MASK
   <span class="kwa">if</span> (cell/<span class="num">5</span>)%2 != <span class="num">0</span> {
      <span class="kwa">return</span> bad_odd_triple[current_triple]
   }
   <span class="kwa">return</span> bad_even_triple[current_triple]
}


<span class="com">/* The recursive solve algorithm.  Try to place each permutation in the upper-</span>
<span class="com"> * leftmost empty cell.  Mark off available pieces as it goes along.</span>
<span class="com"> * Because the board is a bit mask, the piece number and bit mask must be saved</span>
<span class="com"> * at each successful piece placement.  This data is used to create a 50 char</span>
<span class="com"> * array if a solution is found.</span>
<span class="com"> */</span>
<span class="kwa">var</span> (
   avail          <span class="kwb">uint16</span> = <span class="num">0x03FF</span>
   sol_nums       [<span class="num">10</span>]<span class="kwb">int8</span>
   sol_masks      [<span class="num">10</span>]<span class="kwb">uint64</span>
   solutions      [<span class="num">2100</span>][<span class="num">50</span>]<span class="kwb">int8</span>
   solution_count = <span class="num">0</span>
)

<span class="kwa">func</span> <span class="kwd">record_solution</span>() {
   <span class="kwa">for</span> sol_no := <span class="num">0</span>; sol_no &lt; <span class="num">10</span>; sol_no++ {
      sol_mask := sol_masks[sol_no]
      <span class="kwa">for</span> index := <span class="num">0</span>; index &lt; <span class="num">50</span>; index++ {
         <span class="kwa">if</span> sol_mask&amp;<span class="num">1</span> == <span class="num">1</span> {
            solutions[solution_count][index] = sol_nums[sol_no]
            <span class="com">/* Board rotated 180 degrees is a solution too! */</span>
            solutions[solution_count+<span class="num">1</span>][<span class="num">49</span>-index] = sol_nums[sol_no]
         }
         sol_mask = sol_mask &gt;&gt; <span class="num">1</span>
      }
   }
   solution_count += <span class="num">2</span>
}

<span class="kwa">func</span> <span class="kwd">solve</span>(depth, cell <span class="kwb">int8</span>) {
   <span class="kwa">if</span> solution_count &gt;= max_solutions {
      <span class="kwa">return</span>
   }

   <span class="kwa">for</span> board&amp;(<span class="num">1</span>&lt;&lt;<span class="kwb">uint</span>(cell)) != <span class="num">0</span> {
      cell++
   }

   <span class="kwa">for</span> piece := <span class="kwb">int8</span>(<span class="num">0</span>); piece &lt; <span class="num">10</span>; piece++ {
      <span class="kwa">var</span> piece_no_mask <span class="kwb">uint16</span> = <span class="num">1</span> &lt;&lt; <span class="kwb">uint</span>(piece)
      <span class="kwa">if</span> avail&amp;piece_no_mask == <span class="num">0</span> {
         <span class="kwa">continue</span>
      }
      avail ^= piece_no_mask
      max_rots := piece_counts[piece][cell]
      piece_mask := pieces[piece][cell]
      <span class="kwa">for</span> rotation := <span class="num">0</span>; rotation &lt; max_rots; rotation++ {
         <span class="kwa">if</span> board&amp;piece_mask[rotation] == <span class="num">0</span> {
            sol_nums[depth] = piece
            sol_masks[depth] = piece_mask[rotation]
            <span class="kwa">if</span> depth == <span class="num">9</span> {
               <span class="com">/* Solution found!!!!!11!!ONE! */</span>
               <span class="kwd">record_solution</span>()
               avail ^= piece_no_mask
               <span class="kwa">return</span>
            }
            board |= piece_mask[rotation]
            <span class="kwa">if</span> <span class="kwd">boardHasIslands</span>(next_cell[piece][cell][rotation]) == <span class="num">0</span> {
               <span class="kwd">solve</span>(depth+<span class="num">1</span>, next_cell[piece][cell][rotation])
            }
            board ^= piece_mask[rotation]
         }
      }
      avail ^= piece_no_mask
   }
}

<span class="com">/* pretty print a board in the specified hexagonal format */</span>
<span class="kwa">func</span> <span class="kwd">pretty</span>(b *[<span class="num">50</span>]<span class="kwb">int8</span>) {
   <span class="kwa">for</span> i := <span class="num">0</span>; i &lt; <span class="num">50</span>; i += <span class="num">10</span> {
      fmt.<span class="kwd">Printf</span>(<span class="str">&quot;</span><span class="ipl">%c %c %c %c %c</span> <span class="str"></span><span class="esc">\n</span> <span class="str"></span><span class="ipl">%c %c %c %c %c</span> <span class="str"></span><span class="esc">\n</span><span class="str">&quot;</span>, b[i]+<span class="str">'0'</span>, b[i+<span class="num">1</span>]+<span class="str">'0'</span>,
         b[i+<span class="num">2</span>]+<span class="str">'0'</span>, b[i+<span class="num">3</span>]+<span class="str">'0'</span>, b[i+<span class="num">4</span>]+<span class="str">'0'</span>, b[i+<span class="num">5</span>]+<span class="str">'0'</span>, b[i+<span class="num">6</span>]+<span class="str">'0'</span>,
         b[i+<span class="num">7</span>]+<span class="str">'0'</span>, b[i+<span class="num">8</span>]+<span class="str">'0'</span>, b[i+<span class="num">9</span>]+<span class="str">'0'</span>)
   }
   fmt.<span class="kwd">Printf</span>(<span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>)
}

<span class="com">/* Find smallest and largest solutions */</span>
<span class="kwa">func</span> <span class="kwd">smallest_largest</span>() (smallest, largest *[<span class="num">50</span>]<span class="kwb">int8</span>) {
   smallest = &amp;solutions[<span class="num">0</span>]
   largest = &amp;solutions[<span class="num">0</span>]
   <span class="kwa">for</span> i := <span class="num">1</span>; i &lt; solution_count; i++ {
      candidate := &amp;solutions[i]
      <span class="kwa">for</span> j, s := <span class="kwa">range</span> *smallest {
         c := candidate[j]
         <span class="kwa">if</span> c == s {
            <span class="kwa">continue</span>
         }
         <span class="kwa">if</span> c &lt; s {
            smallest = candidate
         }
         <span class="kwa">break</span>
      }
      <span class="kwa">for</span> j, s := <span class="kwa">range</span> *largest {
         c := candidate[j]
         <span class="kwa">if</span> c == s {
            <span class="kwa">continue</span>
         }
         <span class="kwa">if</span> c &gt; s {
            largest = candidate
         }
         <span class="kwa">break</span>
      }
   }
   <span class="kwa">return</span>
}

<span class="kwa">func</span> <span class="kwd">main</span>() {
   flag.<span class="kwd">Parse</span>()
   <span class="kwa">if</span> flag.<span class="kwd">NArg</span>() &gt; <span class="num">0</span> { max_solutions,_ = strconv.<span class="kwd">Atoi</span>( flag.<span class="kwd">Arg</span>(<span class="num">0</span>) ) }

   <span class="kwd">calc_pieces</span>()
   <span class="kwd">calc_rows</span>()
   <span class="kwd">solve</span>(<span class="num">0</span>, <span class="num">0</span>)
   fmt.<span class="kwd">Printf</span>(<span class="str">&quot;</span><span class="ipl">%d</span> <span class="str">solutions found</span><span class="esc">\n\n</span><span class="str">&quot;</span>, solution_count)
   smallest, largest := <span class="kwd">smallest_largest</span>()
   <span class="kwd">pretty</span>(smallest)
   <span class="kwd">pretty</span>(largest)
}
