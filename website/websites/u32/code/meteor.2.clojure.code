<span class="slc">;; The Computer Language Benchmarks Game</span>
<span class="slc">;; http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">;;</span>
<span class="slc">;; contributed by Andy Fingerhut</span>
<span class="slc">;; Based upon ideas from GCC version by Christian Vosteen (good comments!)</span>

<span class="slc">;; This version is intended only to run on Clojure 1.3.  It does not</span>
<span class="slc">;; run on Clojure 1.2.  Lots of type hints removed from Clojure 1.2</span>
<span class="slc">;; version, but it is still very close to the same speed due to 1.3's</span>
<span class="slc">;; primitive support.</span>

(ns meteor
  (:gen-class)
  (:require [clojure.string :as str])
  (:require [clojure.pprint :as pprint]))

(set! *warn-on-reflection* true)


<span class="slc">;; The board is a 50 cell hexagonal pattern.  For    . . . . .</span>
<span class="slc">;; maximum speed the board will be implemented as     . . . . .</span>
<span class="slc">;; 50 bits, which will fit into 2 32-bit ints.       . . . . .</span>
<span class="slc">;; I originally tried 1 64-bit long, but the bit-*    . . . . .</span>
<span class="slc">;; operators in Clojure 1.2 are not as optimized     . . . . .</span>
<span class="slc">;; as they will be in the next version of Clojure.    . . . . .</span>
<span class="slc">;;                                                   . . . . .</span>
<span class="slc">;;                                                    . . . . .</span>
<span class="slc">;; I will represent 0's as empty cells and 1's       . . . . .</span>
<span class="slc">;; as full cells.                                     . . . . .</span>

<span class="slc">;; Here are the numerical indices for each position on the board, also</span>
<span class="slc">;; later called board indices.</span>
<span class="slc">;;</span>
<span class="slc">;;  0   1   2   3   4</span>
<span class="slc">;;    5   6   7   8   9</span>
<span class="slc">;; 10  11  12  13  14</span>
<span class="slc">;;   15  16  17  18  19</span>
<span class="slc">;; 20  21  22  23  24</span>
<span class="slc">;;   25  26  27  28  29</span>
<span class="slc">;; 30  31  32  33  34</span>
<span class="slc">;;   35  36  37  38  39</span>
<span class="slc">;; 40  41  42  43  44</span>
<span class="slc">;;   45  46  47  48  49</span>


<span class="slc">;; Numerical encodings of directions:</span>
<span class="slc">;; 0 East, 1 Southeast, 2 Southwest, 3 West, 4 Northwest, 5 Northeast</span>

<span class="slc">;; Each puzzle piece is specified as a tree.  Every piece consists of</span>
<span class="slc">;; 5 'nodes', each of which occupies one board index.  Each piece has</span>
<span class="slc">;; a root node numbered 0, and every other node (numbered 1 through 4)</span>
<span class="slc">;; specifies its parent node, and the direction to take to get from</span>
<span class="slc">;; the parent to the child (in a default orientation).</span>

<span class="slc">;; In the pictures below, pieces are shown graphically in their</span>
<span class="slc">;; default orientation, with nodes numbered 0 through 4.</span>

<span class="slc">;;   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4</span>
<span class="slc">;;                   </span>
<span class="slc">;;  0 1 2 3    0   3 4   0 1 2     0 1 2     0   3</span>
<span class="slc">;;         4    1 2           3       3       1 2</span>
<span class="slc">;;                           4         4         4</span>
<span class="slc">;;</span>
(<span class="kwa">def</span> piece-defs [ [[<span class="num">0 0</span>] [<span class="num">1 0</span>] [<span class="num">2 0</span>] [<span class="num">3 1</span>]]  <span class="slc">; piece 0</span>
<span class="slc">;;                 ^^^^^ node 1 is East (direction 0) of its parent node 0</span>
<span class="slc">;;                       ^^^^^ node 2 is East of its parent node 1</span>
                  [[<span class="num">0 1</span>] [<span class="num">1 0</span>] [<span class="num">2 5</span>] [<span class="num">3 0</span>]]  <span class="slc">; piece 1</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 0</span>] [<span class="num">2 1</span>] [<span class="num">3 2</span>]]  <span class="slc">; piece 2</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 0</span>] [<span class="num">2 2</span>] [<span class="num">3 1</span>]]  <span class="slc">; piece 3</span>
                  [[<span class="num">0 1</span>] [<span class="num">1 0</span>] [<span class="num">2 5</span>] [<span class="num">2 1</span>]]  <span class="slc">; piece 4</span>
<span class="slc">;;                                    ^ node 4's parent is 2, not 3</span>
<span class="slc">;;</span>
<span class="slc">;;   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9</span>
<span class="slc">;;</span>
<span class="slc">;;    0 1 2     0 1       0 1     0 1        0 1 2 3</span>
<span class="slc">;;       3 4       2 4       2       2 3 4        4</span>
<span class="slc">;;                  3       4 3</span>
<span class="slc">;;</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 0</span>] [<span class="num">2 2</span>] [<span class="num">3 0</span>]]  <span class="slc">; piece 5</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 1</span>] [<span class="num">2 1</span>] [<span class="num">3 5</span>]]  <span class="slc">; piece 6</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 1</span>] [<span class="num">2 1</span>] [<span class="num">3 3</span>]]  <span class="slc">; piece 7</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 1</span>] [<span class="num">2 0</span>] [<span class="num">3 0</span>]]  <span class="slc">; piece 8</span>
                  [[<span class="num">0 0</span>] [<span class="num">1 0</span>] [<span class="num">2 0</span>] [<span class="num">3 2</span>]]  <span class="slc">; piece 9</span>
                  ])

<span class="slc">;; Unlike Christian Vosteen's C program, I will only use 6 directions:</span>
<span class="slc">;;</span>
<span class="slc">;; E SE SW W NW NE</span>
<span class="slc">;;</span>
<span class="slc">;; I will use a different representation for piece shapes so that I</span>
<span class="slc">;; won't need 12 directions for the reason that he introduced them</span>
<span class="slc">;; (i.e. pieces whose shapes are like a tree, and cannot be</span>
<span class="slc">;; represented only with a sequence of directions from one starting</span>
<span class="slc">;; point).</span>


<span class="slc">;; To minimize the amount of work done in the recursive solve function</span>
<span class="slc">;; below, I'm going to precalculate all legal rotations of each piece</span>
<span class="slc">;; at each position on the board. That's 10 pieces x 50 board</span>
<span class="slc">;; positions x 6 rotations x 2 'flip positions' ('top side up' or 'top</span>
<span class="slc">;; side down').  However, not all 6x2=12 orientations will fit on</span>
<span class="slc">;; every cell.  Only keep the ones that do.  The pieces are going to</span>
<span class="slc">;; be pairs of 32-bit ints just like the board so they can be</span>
<span class="slc">;; bitwise-anded with the board to determine if they fit.  I'm also</span>
<span class="slc">;; going to record the next possible open cell for each piece and</span>
<span class="slc">;; location to reduce the burden on the solve function.</span>


<span class="slc">;; Returns the direction rotated 60 degrees clockwise</span>
(<span class="kwa">defn</span> rotate [dir]
  (<span class="kwc">case</span> (int dir)
        <span class="num">0 1</span>
        <span class="num">1 2</span>
        <span class="num">2 3</span>
        <span class="num">3 4</span>
        <span class="num">4 5</span>
        <span class="num">5 0</span>))

<span class="slc">;; Returns the direction flipped on the horizontal axis</span>
(<span class="kwa">defn</span> flip [dir]
  (<span class="kwc">case</span> (int dir)
        <span class="num">0 0</span>
        <span class="num">1 5</span>
        <span class="num">2 4</span>
        <span class="num">3 3</span>
        <span class="num">4 2</span>
        <span class="num">5 1</span>))


<span class="slc">;; Returns the new cell index from the specified cell in the specified</span>
<span class="slc">;; direction.  The index is only valid if the starting cell and</span>
<span class="slc">;; direction have been checked by the out-of-bounds function first.</span>

(<span class="kwa">defn</span> shift [cell dir]
  (<span class="kwc">case</span> (int dir)
        <span class="num">0</span> (inc cell)
        <span class="num">1</span> (<span class="kwc">if</span> (odd? (quot cell <span class="num">5</span>))
              (+ cell <span class="num">6</span>)
              (+ cell <span class="num">5</span>))
        <span class="num">2</span> (<span class="kwc">if</span> (odd? (quot cell <span class="num">5</span>))
              (+ cell <span class="num">5</span>)
              (+ cell <span class="num">4</span>))
        <span class="num">3</span>  (dec cell)
        <span class="num">4</span> (<span class="kwc">if</span> (odd? (quot cell <span class="num">5</span>))
              (- cell <span class="num">5</span>)
              (- cell <span class="num">6</span>))
        <span class="num">5</span> (<span class="kwc">if</span> (odd? (quot cell <span class="num">5</span>))
              (- cell <span class="num">4</span>)
              (- cell <span class="num">5</span>))))


(<span class="kwa">defn</span> make-shift-table []
  (object-array (<span class="kwd">map</span> (<span class="kwa">fn</span> [cell-idx]
                       (long-array (<span class="kwd">map</span> (<span class="kwa">fn</span> [dir] (shift cell-idx dir))
                                        (<span class="kwd">range</span> <span class="num">6</span>))))
                     (<span class="kwd">range</span> <span class="num">50</span>))))


<span class="slc">;; Returns wether the specified cell and direction will land outside</span>
<span class="slc">;; of the board.  Used to determine if a piece is at a legal board</span>
<span class="slc">;; location or not.</span>

(<span class="kwa">defn</span> out-of-bounds [cell dir]
  (<span class="kwc">case</span> (int dir)
        <span class="num">0</span> (== (rem cell <span class="num">5</span>) <span class="num">4</span>)       <span class="slc">; cell is on the right side</span>
        <span class="num">1</span> (or (== (rem cell <span class="num">10</span>) <span class="num">9</span>)  <span class="slc">; cell is on &quot;extreme&quot; right side</span>
              (&gt;= cell <span class="num">45</span>))         <span class="slc">; or the bottom row</span>
        <span class="num">2</span> (or (== (rem cell <span class="num">10</span>) <span class="num">0</span>)  <span class="slc">; cell is on &quot;extreme&quot; left side</span>
              (&gt;= cell <span class="num">45</span>))         <span class="slc">; or the bottom row</span>
        <span class="num">3</span> (== (rem cell <span class="num">5</span>) <span class="num">0</span>)       <span class="slc">; cell is on the left side</span>
        <span class="num">4</span> (or (== (rem cell <span class="num">10</span>) <span class="num">0</span>)  <span class="slc">; cell is on &quot;extreme&quot; left side</span>
              (&lt; cell <span class="num">5</span>))           <span class="slc">; or the top row</span>
        <span class="num">5</span> (or (== (rem cell <span class="num">10</span>) <span class="num">9</span>)  <span class="slc">; cell is on &quot;extreme&quot; right side</span>
              (&lt; cell <span class="num">5</span>))))         <span class="slc">; or the top row</span>


(<span class="kwa">defn</span> make-oob-table []
  (object-array (<span class="kwd">map</span> (<span class="kwa">fn</span> [cell-idx]
                       (boolean-array (<span class="kwd">map</span> (<span class="kwa">fn</span> [dir] (out-of-bounds cell-idx dir))
                                           (<span class="kwd">range</span> <span class="num">6</span>))))
                     (<span class="kwd">range</span> <span class="num">50</span>))))


<span class="slc">;; Return a piece that is the the same as the one given as argument,</span>
<span class="slc">;; except rotated 60 degrees clockwise.</span>

(<span class="kwa">defn</span> rotate-piece [piece]
  (vec (<span class="kwd">map</span> (<span class="kwa">fn</span> [[parent dir]] [parent (rotate dir)]) piece)))


<span class="slc">;; Return a piece that is the the same as the one given as argument,</span>
<span class="slc">;; except flipped along the horizontal axis.</span>

(<span class="kwa">defn</span> flip-piece [piece]
  (vec (<span class="kwd">map</span> (<span class="kwa">fn</span> [[parent dir]] [parent (flip dir)]) piece)))


<span class="slc">;; Convenience function to calculate and return a vector of all of the</span>
<span class="slc">;; board indices that a piece's nodes will be in, if that piece's root</span>
<span class="slc">;; node is at root-index.</span>

<span class="slc">;; Note that no check is made to see whether the piece actually fits</span>
<span class="slc">;; on the board or not, so some of the returned index values may be</span>
<span class="slc">;; nonsense.  See cells-fit-on-board for a way to check this.</span>

(<span class="kwa">defn</span> calc-cell-indices [piece root-index ^objects shift-table]
  (<span class="kwb">loop</span> [indices (transient [root-index])
         node (int <span class="num">0</span>)]
    (<span class="kwc">if</span> (== node <span class="num">4</span>)
      (persistent! indices)
      <span class="slc">;; else</span>
      <span class="slc">;; Note that information about node n of a piece is in (piece</span>
      <span class="slc">;; (dec n)) We're intentionally iterating the value 'node' 0</span>
      <span class="slc">;; through 3 rather than 1 through 4 here just to avoid</span>
      <span class="slc">;; calculating (dec node) here.</span>
      (<span class="kwc">let</span> [pair (piece node)
            parent (int (pair <span class="num">0</span>))
            dir (int (pair <span class="num">1</span>))
            <span class="slc">;[parent dir] (piece node)</span>
            parent-loc (int (indices parent))]
        (<span class="kwb">recur</span> (conj! indices
                      (<span class="kwc">if</span> (and (&lt; parent-loc <span class="num">50</span>) (not (neg? parent-loc)))
                        (<span class="kwc">let</span> [^longs shift-table-for-parent-loc
                              (aget shift-table parent-loc)]
                          (aget shift-table-for-parent-loc dir))
                        <span class="num">0</span>))  <span class="slc">;; dummy value</span>
               (inc node))))))


<span class="slc">;; Convenience function to calculate if a piece fits on the board.</span>
<span class="slc">;; Node 0 of the piece, at board index (indices 0), is assumed to be</span>
<span class="slc">;; on the board, but the other nodes may be off.</span>

(<span class="kwa">defmacro</span> node-fits [node-info indices ^objects oob-table]
  `(<span class="kwc">let</span> [pair# ~node-info
         parent-node-num# (int (pair# <span class="num">0</span>))
         dir# (int (pair# <span class="num">1</span>))
         parent-idx# (int (~indices parent-node-num#))
         <span class="slc">;^booleans oob-for-parent-idx# (aget ~oob-table parent-idx#)]</span>
         ^<span class="str">&quot;[Z&quot;</span> oob-for-parent-idx# (aget ~oob-table parent-idx#)]
     (not (aget oob-for-parent-idx# dir#))))


(<span class="kwa">defn</span> cells-fit-on-board [piece indices ^objects oob-table]
  (and
   (node-fits (piece <span class="num">0</span>) indices oob-table)  <span class="slc">;; check node 1 of the piece</span>
   (node-fits (piece <span class="num">1</span>) indices oob-table)  <span class="slc">;; node 2, etc.</span>
   (node-fits (piece <span class="num">2</span>) indices oob-table)
   (node-fits (piece <span class="num">3</span>) indices oob-table)))


<span class="slc">;; Fill the entire board going cell by cell, starting from index i.</span>
<span class="slc">;; If any cells are &quot;trapped&quot; they will be left alone.</span>

(<span class="kwa">defn</span> fill-contiguous-space! [^longs board i
                              ^objects shift-table ^objects oob-table]
  (letfn
      [(fill-helper! [i]
         (<span class="kwc">let</span> [i (int i)
               ^booleans oob-table-row (aget oob-table i)
               ^longs shift-table-row (aget shift-table i)]
           (<span class="kwc">when</span> (zero? (aget board i))
             (aset board i (int <span class="num">1</span>))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">0</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">0</span>))))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">1</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">1</span>))))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">2</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">2</span>))))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">3</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">3</span>))))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">4</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">4</span>))))
             (<span class="kwc">if</span> (not (aget oob-table-row (int <span class="num">5</span>)))
               (fill-helper! (aget shift-table-row (int <span class="num">5</span>)))))))]
    (fill-helper! i)))


(<span class="kwa">defn</span> empty-cells [^longs board-arr]
  (- <span class="num">50</span>
     (<span class="kwc">let</span> [^longs a board-arr]
       (<span class="kwb">loop</span> [i <span class="num">49</span>
              ret <span class="num">0</span>]
         (<span class="kwc">if</span> (neg? i)
           ret
           (<span class="kwb">recur</span> (dec i)
                  (+ ret (aget a i))))))))


<span class="slc">;; Warning: Modifies its argument board-arr</span>

(<span class="kwa">defn</span> board-empty-region-sizes! [^longs board-arr
                                 ^objects shift-table ^objects oob-table]
  (<span class="kwb">loop</span> [sizes (transient [])
         num-empty (empty-cells board-arr)
         last-empty-cell <span class="num">50</span>]
    (<span class="kwc">if</span> (zero? num-empty)
      (persistent! sizes)
      <span class="slc">;; else</span>
      (<span class="kwc">let</span> [next-last-empty-cell (long (<span class="kwb">loop</span> [i (int (dec last-empty-cell))]
                                         (<span class="kwc">if</span> (zero? (aget board-arr i))
                                           i
                                           (<span class="kwb">recur</span> (dec i)))))]
        (fill-contiguous-space! board-arr next-last-empty-cell shift-table
                                oob-table)
        (<span class="kwc">let</span> [next-num-empty (empty-cells board-arr)]
          (<span class="kwb">recur</span> (conj! sizes (- num-empty next-num-empty))
                 next-num-empty
                 next-last-empty-cell))))))


<span class="slc">;; Generate the pair of longs (of which we only care about the 32</span>
<span class="slc">;; lsbs) that will later be anded with the board to determine if it</span>
<span class="slc">;; fits.</span>

(<span class="kwa">defn</span> bitmask-from-indices [indices]
  [(reduce bit-or (<span class="kwd">map</span> (<span class="kwa">fn</span> [i] (<span class="kwc">if</span> (&lt; i <span class="num">25</span>) (bit-shift-left <span class="num">1</span> i) <span class="num">0</span>))
                       indices))
   (reduce bit-or (<span class="kwd">map</span> (<span class="kwa">fn</span> [i] (<span class="kwc">if</span> (&lt; i <span class="num">25</span>) <span class="num">0</span> (bit-shift-left <span class="num">1</span> (- i <span class="num">25</span>))))
                       indices))])


(<span class="kwa">defn</span> print-board [^longs soln]
  (<span class="kwb">dotimes</span> [i <span class="num">50</span>]
    (<span class="kwc">when</span> (zero? (rem i <span class="num">5</span>))
      (println <span class="str">&quot;&quot;</span>))
    (<span class="kwc">when</span> (== (rem i <span class="num">10</span>) <span class="num">5</span>)
      (print <span class="str">&quot; &quot;</span>))
    (printf <span class="str">&quot;%d &quot;</span> (aget soln i))))


<span class="slc">;; Solutions are encoded as vectors of 50 integers, one for each board</span>
<span class="slc">;; index, where each integer is in the range [0,9], representing one</span>
<span class="slc">;; of the 5 parts of a piece that is in that board index.</span>

(<span class="kwa">defn</span> encode-solution [^longs piece-num-arr ^longs mask-arr0 ^longs mask-arr1]
  (<span class="kwc">let</span> [soln (long-array <span class="num">50</span> -<span class="num">1</span>)]
    (<span class="kwb">dotimes</span> [i <span class="num">25</span>]
      (<span class="kwc">let</span> [idx-mask (bit-shift-left (int <span class="num">1</span>) i)]
        (<span class="kwb">loop</span> [p <span class="num">0</span>]
          (<span class="kwc">if</span> (&lt; p <span class="num">10</span>)
            (<span class="kwc">if</span> (zero? (bit-and (aget mask-arr0 p) idx-mask))
              (<span class="kwb">recur</span> (inc p))
              (aset soln i (aget piece-num-arr p)))))
        (<span class="kwb">loop</span> [p <span class="num">0</span>]
          (<span class="kwc">if</span> (&lt; p <span class="num">10</span>)
            (<span class="kwc">if</span> (zero? (bit-and (aget mask-arr1 p) idx-mask))
              (<span class="kwb">recur</span> (inc p))
              (aset soln (+ <span class="num">25</span> i) (aget piece-num-arr p)))))))
    soln))


<span class="slc">;; To thin the number of pieces, I calculate if any of them trap any</span>
<span class="slc">;; empty cells at the edges, such that the number of trapped empty</span>
<span class="slc">;; cells is not a multiple of 5.  All pieces have 5 cells, so any such</span>
<span class="slc">;; trapped regions cannot possibly be filled with any pieces.</span>

(<span class="kwa">defn</span> one-piece-has-island [indices shift-table oob-table]
  (<span class="kwc">let</span> [temp-board (long-array <span class="num">50</span>)]
    <span class="slc">;; Mark the piece board positions as filled</span>
    (<span class="kwb">doseq</span> [idx indices]
      (aset temp-board idx <span class="num">1</span>))
    (<span class="kwc">let</span> [empty-region-sizes (board-empty-region-sizes! temp-board shift-table
                                                        oob-table)]
      (not (every? #(zero? (rem % <span class="num">5</span>)) empty-region-sizes)))))


<span class="slc">;; Calculate the lowest possible open cell if the piece is placed on</span>
<span class="slc">;; the board.  Used to later reduce the amount of time searching for</span>
<span class="slc">;; open cells in the solve function.</span>

(<span class="kwa">defn</span> first-empty-cell-after [minimum indices]
  (<span class="kwc">let</span> [idx-set (set indices)]
    (<span class="kwb">loop</span> [i minimum]
      (<span class="kwc">if</span> (idx-set i)
        (<span class="kwb">recur</span> (inc i))
        i))))


<span class="slc">;; We calculate only half of piece 3's rotations.  This is because any</span>
<span class="slc">;; solution found has an identical solution rotated 180 degrees.  Thus</span>
<span class="slc">;; we can reduce the number of attempted pieces in the solve algorithm</span>
<span class="slc">;; by not including the 180- degree-rotated pieces of ONE of the</span>
<span class="slc">;; pieces.  I chose piece 3 because it gave me the best time ;)</span>

(<span class="kwa">def</span> +piece-num-to-do-only-3-rotations+ <span class="num">3</span>)

<span class="slc">;; Calculate every legal rotation for each piece at each board</span>
<span class="slc">;; location.</span>

(<span class="kwa">defn</span> calc-pieces [pieces shift-table oob-table]
  (<span class="kwc">let</span> [npieces (count pieces)
        ^objects tbl (object-array npieces)] <span class="slc">; first index is piece-num</span>
    (<span class="kwb">dotimes</span> [piece-num npieces]
      (aset tbl piece-num (object-array <span class="num">50</span>))
      (<span class="kwc">let</span> [^objects piece-arr (aget tbl piece-num)]
        (<span class="kwb">dotimes</span> [cell <span class="num">50</span>]  <span class="slc">; second index is board index</span>
          <span class="slc">;; Start with transient vectors.  Later we will change them to</span>
          <span class="slc">;; Java arrays after we know how long to make them.</span>
          (aset piece-arr cell (transient [])))))
    <span class="slc">;; Find all possible good piece placements</span>
    (<span class="kwb">dotimes</span> [p npieces]
      (<span class="kwc">let</span> [unrotated-piece (pieces p)
            num-rots (<span class="kwc">if</span> (= p +piece-num-to-do-only-3-rotations+) <span class="num">3 6</span>)]
        (<span class="kwb">dotimes</span> [flip <span class="num">2</span>]
          (<span class="kwb">loop</span> [rot <span class="num">0</span>
                 piece (<span class="kwc">if</span> (zero? flip)
                         unrotated-piece
                         (flip-piece unrotated-piece))]
            (<span class="kwc">when</span> (&lt; rot num-rots)
              (<span class="kwb">dotimes</span> [cell <span class="num">50</span>]
                (<span class="kwc">let</span> [indices (calc-cell-indices piece cell shift-table)]
                  (<span class="kwc">when</span> (and (cells-fit-on-board piece indices oob-table)
                             (not (one-piece-has-island indices shift-table
                                                        oob-table)))
                    (<span class="kwc">let</span> [minimum (apply min indices)
                          [piece-mask0 piece-mask1] (bitmask-from-indices
                                                     indices)
                          next-index (long (first-empty-cell-after minimum
                                                                   indices))]

                      (<span class="kwc">let</span> [^longs good-placement (long-array <span class="num">3</span>)
                            ^objects piece-arr (aget tbl p)]
                        (aset good-placement <span class="num">0</span> (long piece-mask0))
                        (aset good-placement <span class="num">1</span> (long piece-mask1))
                        (aset good-placement <span class="num">2</span> next-index)
                        <span class="slc">;; Put it in the table</span>
                        (aset piece-arr minimum
                              (conj! (aget piece-arr minimum) good-placement))
                        )))))
              (<span class="kwb">recur</span> (inc rot) (rotate-piece piece)))))))
    <span class="slc">;; Make all transient vectors into Java object arrays</span>
    (<span class="kwb">dotimes</span> [piece-num npieces]
      (<span class="kwc">let</span> [^objects piece-arr (aget tbl piece-num)]
        (<span class="kwb">dotimes</span> [cell <span class="num">50</span>]
          (<span class="kwc">let</span> [cur-vec (persistent! (aget piece-arr cell))]
            (aset piece-arr cell (object-array cur-vec))))))
    tbl))



<span class="slc">;; first-empty-index-aux assumptions: idx is in the range [0,24].</span>
<span class="slc">;; half-board is an integer that has bits 25 and higher equal to 0, so</span>
<span class="slc">;; the loop is guaranteed to terminate, and the return value will be</span>
<span class="slc">;; in the range [0,25].</span>

(<span class="kwa">defmacro</span> first-empty-index-aux [idx half-board]
  `(<span class="kwb">loop</span> [i# ~idx
          hb# (bit-shift-right ~half-board ~idx)]
     (<span class="kwc">if</span> (zero? (bit-and hb# <span class="num">1</span>))
       i#
       (<span class="kwb">recur</span> (inc i#) (bit-shift-right hb# <span class="num">1</span>)))))


(<span class="kwa">defmacro</span> first-empty-index [idx board0 board1]
  `(<span class="kwc">if</span> (&lt; ~idx <span class="num">25</span>)
     (<span class="kwc">let</span> [i# (first-empty-index-aux ~idx ~board0)]
       (<span class="kwc">if</span> (== i# <span class="num">25</span>)
         (+ <span class="num">25</span> (first-empty-index-aux <span class="num">0</span> ~board1))
         i#))
     (+ <span class="num">25</span> (first-empty-index-aux (- ~idx <span class="num">25</span>) ~board1))))


<span class="slc">;; Note: board-empty-region-sizes! runs faster if there are fewer</span>
<span class="slc">;; empty cells to fill.  So fill as much of the board as we can before</span>
<span class="slc">;; putting in the 3 partially filled rows.  There must be at least one</span>
<span class="slc">;; completely empty row at the bottom in order to correctly determine</span>
<span class="slc">;; whether these 3 rows are a bad triple.</span>

(<span class="kwa">defn</span> create-triples [shift-table oob-table]
  (<span class="kwc">let</span> [bad-even-triples (long-array (/ (bit-shift-left <span class="num">1 15</span>) <span class="num">32</span>))
        bad-odd-triples (long-array (/ (bit-shift-left <span class="num">1 15</span>) <span class="num">32</span>))
        temp-arr (long-array <span class="num">50</span>)]
    <span class="slc">;; Fill rows 0..5 completely.</span>
    (<span class="kwb">dotimes</span> [i <span class="num">30</span>]
      (aset temp-arr i <span class="num">1</span>))
    (<span class="kwb">dotimes</span> [row6 <span class="num">32</span>]
      (<span class="kwb">dotimes</span> [row7 <span class="num">32</span>]
        (<span class="kwb">dotimes</span> [row8 <span class="num">32</span>]
          (<span class="kwc">let</span> [board (bit-or (bit-or row6 (bit-shift-left row7 <span class="num">5</span>))
                              (bit-shift-left row8 <span class="num">10</span>))]
            (<span class="kwb">dotimes</span> [i <span class="num">15</span>]
              (aset temp-arr (+ <span class="num">30</span> i)
                    (bit-and <span class="num">1</span> (bit-shift-right board i))))
            (<span class="kwb">dotimes</span> [i <span class="num">5</span>]   <span class="slc">;; Row 9 is completely empty to start with</span>
              (aset temp-arr (+ <span class="num">45</span> i) <span class="num">0</span>))
            (<span class="kwc">let</span> [empty-region-sizes (board-empty-region-sizes!
                                      temp-arr shift-table oob-table)
                  <span class="slc">;; Note that we assume board-empty-region-sizes!</span>
                  <span class="slc">;; returns a sequence, where the first element is</span>
                  <span class="slc">;; the size of the empty region that includes the</span>
                  <span class="slc">;; last cell, number 49.  Thus we can eliminate the</span>
                  <span class="slc">;; number of empty cells in that region simply by</span>
                  <span class="slc">;; removing the first element.</span>
                  empty-sizes-except-bottom (<span class="kwd">rest</span> empty-region-sizes)
                  j (bit-shift-right board <span class="num">5</span>)
                  i (bit-and board (int <span class="num">0x1F</span>))]
              (when-not (every? #(zero? (rem % <span class="num">5</span>)) empty-sizes-except-bottom)
                <span class="slc">;; then it is possible for pieces to fill the empty</span>
                <span class="slc">;; regions</span>
                (aset bad-even-triples j
                      (bit-or (aget bad-even-triples j)
                              (bit-shift-left <span class="num">1</span> i)))))))))
    <span class="slc">;; Fill rows 0..4 completely.</span>
    (<span class="kwb">dotimes</span> [i <span class="num">25</span>]
      (aset temp-arr i <span class="num">1</span>))
    (<span class="kwb">dotimes</span> [row5 <span class="num">32</span>]
      (<span class="kwb">dotimes</span> [row6 <span class="num">32</span>]
        (<span class="kwb">dotimes</span> [row7 <span class="num">32</span>]
          (<span class="kwc">let</span> [board-rows-1-3 (bit-or (bit-or row5 (bit-shift-left row6 <span class="num">5</span>))
                                       (bit-shift-left row7 <span class="num">10</span>))]
            (<span class="kwb">dotimes</span> [i <span class="num">15</span>]
              (aset temp-arr (+ <span class="num">25</span> i)
                    (bit-and <span class="num">1</span> (bit-shift-right board-rows-1-3 i))))
            (<span class="kwb">dotimes</span> [i <span class="num">10</span>]  <span class="slc">;; Rows 8 and 9 are completely empty to start with</span>
              (aset temp-arr (+ <span class="num">40</span> i) <span class="num">0</span>))
            (<span class="kwc">let</span> [empty-region-sizes (board-empty-region-sizes!
                                      temp-arr shift-table oob-table)
                  empty-sizes-except-bottom (<span class="kwd">rest</span> empty-region-sizes)
                  j (bit-shift-right board-rows-1-3 <span class="num">5</span>)
                  i (bit-and board-rows-1-3 <span class="num">0x1F</span>)]
              (when-not (every? #(zero? (rem % <span class="num">5</span>)) empty-sizes-except-bottom)
                (aset bad-odd-triples j
                      (bit-or (aget bad-odd-triples j)
                              (bit-shift-left <span class="num">1</span> i)))
                ))))))
    [bad-even-triples bad-odd-triples]))


(<span class="kwa">def</span> num-solutions (long-array <span class="num">1</span>))
(<span class="kwa">def</span> all-solutions (object-array <span class="num">2200</span>))

<span class="slc">;; See comments above +piece-num-to-do-only-3-rotations+.  Each</span>
<span class="slc">;; solution is thus recorded twice.  Reversing the solution has the</span>
<span class="slc">;; effect of rotating it 180 degrees.</span>

(<span class="kwa">defn</span> record-solution! [^longs soln]
  (<span class="kwc">let</span> [^longs num-solutions num-solutions
        ^objects all-solutions all-solutions
        n (aget num-solutions <span class="num">0</span>)
        ^longs rotated-soln (aclone soln)
        len (alength soln)
        len-1 (dec len)]
    (aset all-solutions n soln)
    (<span class="kwb">dotimes</span> [i (/ len <span class="num">2</span>)]
      (<span class="kwc">let</span> [tmp (aget rotated-soln i)
            other-idx (- len-1 i)]
        (aset rotated-soln i (aget rotated-soln other-idx))
        (aset rotated-soln other-idx tmp)))
    (aset all-solutions (inc n) rotated-soln)
    (aset num-solutions <span class="num">0</span> (+ n <span class="num">2</span>))))


<span class="slc">;; Assume all args have been type-hinted to int in the environment</span>
<span class="slc">;; where the macro board-has-no-islands is called.</span>

(<span class="kwa">defmacro</span> board-has-no-islands [board0 board1 index
                                ^longs bad-even-triples
                                ^longs bad-odd-triples]
  `(<span class="kwc">if</span> (&gt;= ~index <span class="num">40</span>)
     true
     (<span class="kwc">let</span> [row-num# (long (/ ~index <span class="num">5</span>))
           current-3-rows#
           (<span class="kwc">case</span> row-num#
                 <span class="num">0</span> (bit-and <span class="num">0x7FFF</span> ~board0)
                 <span class="num">1</span> (bit-and <span class="num">0x7FFF</span> (bit-shift-right ~board0 <span class="num">5</span>))
                 <span class="num">2</span> (bit-and <span class="num">0x7FFF</span> (bit-shift-right ~board0 <span class="num">10</span>))
                 <span class="num">3</span> (bit-or (bit-shift-right ~board0 <span class="num">15</span>)
                           (bit-shift-left (bit-and <span class="num">0x1F</span> ~board1)
                                           <span class="num">10</span>))
                 <span class="num">4</span> (bit-or (bit-shift-right ~board0 <span class="num">20</span>)
                           (bit-shift-left (bit-and <span class="num">0x3FF</span> ~board1) <span class="num">5</span>))
                 <span class="num">5</span> (bit-and <span class="num">0x7FFF</span> ~board1)
                 <span class="num">6</span> (bit-and <span class="num">0x7FFF</span> (bit-shift-right ~board1 <span class="num">5</span>))
                 <span class="num">7</span> (bit-and <span class="num">0x7FFF</span> (bit-shift-right ~board1 <span class="num">10</span>)))
           int-num# (bit-shift-right current-3-rows# <span class="num">5</span>)
           bit-num# (bit-and current-3-rows# <span class="num">0x1F</span>)
           even-row# (zero? (bit-and row-num# <span class="num">1</span>))]
       (<span class="kwc">if</span> even-row#
         (zero? (bit-and <span class="num">1</span> (bit-shift-right (aget ~bad-even-triples int-num#)
                                            bit-num#)))
         (zero? (bit-and <span class="num">1</span> (bit-shift-right (aget ~bad-odd-triples int-num#)
                                            bit-num#)))))))


<span class="slc">;; Arguments to solve-helper:</span>

<span class="slc">;; depth is 0 on the first call, and is 1 more for each level of</span>
<span class="slc">;; nested recursive call.  It is equal to the number of pieces placed</span>
<span class="slc">;; on the board in the partial solution so far.</span>

<span class="slc">;; board is a pair of 32-bit longs representing which board cells are</span>
<span class="slc">;; occupied (bit value 1) or empty (bit value 0), based upon the</span>
<span class="slc">;; pieces placed so far.  Bits positions 0..24 of board0 represent</span>
<span class="slc">;; board indices 0..24, and bit positions 0..24 of board1 represent</span>
<span class="slc">;; board indices 25..49.</span>

<span class="slc">;; cell is the board index in [0,49] that should be checked first to</span>
<span class="slc">;; see if it is empty.</span>

<span class="slc">;; placed-piece-bit-vec is an int where its 10 least significant bits</span>
<span class="slc">;; represent the set of the piece numbers, each in the range [0,9],</span>
<span class="slc">;; that have been placed so far in the current configuration.  If bit</span>
<span class="slc">;; i is 1, i in [0,9], then piece i has already been placed.</span>

<span class="slc">;; piece-num-arr is an array of the piece-nums placed so far, in the</span>
<span class="slc">;; order they were placed, i.e. depth order.  (aget piece-num-arr 0)</span>
<span class="slc">;; was placed at depth 0, etc.  (named sol_nums in GCC program)</span>

<span class="slc">;; mask-arr is an array of the bitmasks of the pieces placed so far,</span>
<span class="slc">;; in the order they were placed.  (named sol_masks in GCC program)</span>

(<span class="kwa">defn</span> solve! [^objects tbl ^longs bad-even-triples ^longs bad-odd-triples]
  (letfn
      [(solve-helper [depth board0 board1 orig-cell placed-piece-bit-vec
                      ^longs piece-num-arr ^longs mask-arr0 ^longs mask-arr1]
         (<span class="kwc">let</span> [depth depth
               board0 board0
               board1 board1
               orig-cell orig-cell
               cell (first-empty-index orig-cell board0 board1)
               placed-piece-bit-vec-int placed-piece-bit-vec]
           (<span class="kwb">loop</span> [piece-num <span class="num">0</span>
                  piece-num-mask <span class="num">1</span>]
             (<span class="kwc">when</span> (&lt; piece-num <span class="num">10</span>)
               (<span class="kwc">when</span> (zero? (bit-and placed-piece-bit-vec-int piece-num-mask))
                 (<span class="kwc">let</span> [^objects piece-arr (aget tbl piece-num)
                       ^objects placements (aget piece-arr cell)]
                   (<span class="kwb">dotimes</span> [i (alength placements)]
                     (<span class="kwc">let</span> [^longs placement (aget placements i)
                           piece-mask0 (aget placement <span class="num">0</span>)
                           piece-mask1 (aget placement <span class="num">1</span>)
                           next-index (aget placement <span class="num">2</span>)
                           piece-num-int piece-num]
                       (<span class="kwc">when</span> (and (zero? (bit-and board0 piece-mask0))
                                  (zero? (bit-and board1 piece-mask1)))
                         (<span class="kwc">if</span> (== depth <span class="num">9</span>)
                           <span class="slc">;; Solution found!</span>
                           (do
                             (aset piece-num-arr depth piece-num-int)
                             (aset mask-arr0 depth piece-mask0)
                             (aset mask-arr1 depth piece-mask1)
                             (<span class="kwc">let</span> [sol1 (encode-solution piece-num-arr
                                                         mask-arr0 mask-arr1)]
                               (record-solution! sol1)))
                           <span class="slc">;; else</span>
                           (<span class="kwc">let</span> [next-board0 (bit-or board0 piece-mask0)
                                 next-board1 (bit-or board1 piece-mask1)]
                             (<span class="kwc">when</span> (board-has-no-islands next-board0 next-board1
                                                         next-index
                                                         bad-even-triples
                                                         bad-odd-triples)
                               (aset piece-num-arr depth piece-num-int)
                               (aset mask-arr0 depth piece-mask0)
                               (aset mask-arr1 depth piece-mask1)
                               (solve-helper
                                (inc depth)
                                next-board0 next-board1
                                next-index
                                (bit-or placed-piece-bit-vec-int
                                        (bit-shift-left <span class="num">1</span> piece-num-int))
                                piece-num-arr
                                mask-arr0 mask-arr1)))))))))
               (<span class="kwb">recur</span> (inc piece-num) (bit-shift-left piece-num-mask <span class="num">1</span>))
               ))))]
    (solve-helper <span class="num">0 0 0 0 0</span> (long-array <span class="num">10</span>) (long-array <span class="num">10</span>) (long-array <span class="num">10</span>))))


(<span class="kwa">defn</span> compare-long-arrays [^longs a ^longs b]
  (<span class="kwc">let</span> [len (min (alength a) (alength b))]
    (<span class="kwb">loop</span> [i <span class="num">0</span>]
      (<span class="kwc">if</span> (&lt; i len)
        (<span class="kwc">let</span> [elem-a (aget a i)
              elem-b (aget b i)]
          (<span class="kwc">if</span> (== elem-a elem-b)
            (<span class="kwb">recur</span> (inc i))
            (- elem-a elem-b)))
        <span class="num">0</span>))))


(<span class="kwa">defn</span> -main [&amp; args]
  (<span class="kwc">let</span> [shift-table (make-shift-table)
        oob-table (make-oob-table)
        tbl (calc-pieces piece-defs shift-table oob-table)
        [bad-even-triples bad-odd-triples] (create-triples shift-table
                                                           oob-table)]
    (solve! tbl bad-even-triples bad-odd-triples)
    (<span class="kwc">let</span> [^longs num-solutions num-solutions
          n (aget num-solutions <span class="num">0</span>)
          sorted-solns (<span class="kwd">sort</span> compare-long-arrays (<span class="kwd">take</span> n (seq all-solutions)))]
      (println (format <span class="str">&quot;%d solutions found&quot;</span> n))
      (print-board (<span class="kwd">first</span> sorted-solns))
      (println)
      (print-board (nth sorted-solns (dec n)))
      (println)
      (println))))  <span class="slc">; Just to match the output of the other programs exactly</span>
