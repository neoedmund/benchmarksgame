<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// http://benchmarksgame.alioth.debian.org/</span>
<span class="slc">//</span>
<span class="slc">// contributed by the Rust Project Developers</span>
<span class="slc">// contributed by TeXitoi</span>

<span class="kwa">use</span> std::iter::repeat;
<span class="kwa">use</span> std::sync::Arc;
<span class="kwa">use</span> std::sync::mpsc::channel;
<span class="kwa">use</span> std::thread::spawn;

<span class="slc">//</span>
<span class="slc">// Utilities.</span>
<span class="slc">//</span>

<span class="slc">// returns an infinite iterator of repeated applications of f to x,</span>
<span class="slc">// i.e. [x, f(x), f(f(x)), ...], as haskell iterate function.</span>
<span class="kwa">fn</span> iterate&lt;T, F&gt;(x: T, f: F) -&gt; Iterate&lt;T, F&gt; <span class="kwa">where</span> F: FnMut(&amp;T) -&gt; T {
    Iterate { f: f, next: x }
}
<span class="kwa">struct</span> Iterate&lt;T, F&gt; <span class="kwa">where</span> F: FnMut(&amp;T) -&gt; T { f: F, next: T }
<span class="kwa">impl</span>&lt;T, F&gt; Iterator <span class="kwa">for</span> Iterate&lt;T, F&gt; <span class="kwa">where</span> F: FnMut(&amp;T) -&gt; T {
    <span class="kwa">type</span> Item = T;

    <span class="kwa">fn</span> next(&amp;<span class="kwa">mut self</span>) -&gt; Option&lt;T&gt; {
        <span class="kwa">let mut</span> res = (<span class="kwa">self</span>.f)(&amp;<span class="kwa">self</span>.next);
        std::mem::swap(&amp;<span class="kwa">mut</span> res, &amp;<span class="kwa">mut self</span>.next);
        Some(res)
    }
}

<span class="slc">// a linked list using borrowed next.</span>
<span class="kwa">enum</span> List&lt;'a, T:'a&gt; {
    Nil,
    Cons(T, &amp;'a List&lt;'a, T&gt;)
}
<span class="kwa">struct</span> ListIterator&lt;'a, T:'a&gt; {
    cur: &amp;'a List&lt;'a, T&gt;
}
<span class="kwa">impl</span>&lt;'a, T&gt; List&lt;'a, T&gt; {
    <span class="kwa">fn</span> iter(&amp;'a <span class="kwa">self</span>) -&gt; ListIterator&lt;'a, T&gt; {
        ListIterator { cur: <span class="kwa">self</span> }
    }
}
<span class="kwa">impl</span>&lt;'a, T&gt; Iterator <span class="kwa">for</span> ListIterator&lt;'a, T&gt; {
    <span class="kwa">type</span> Item = &amp;'a T;

    <span class="kwa">fn</span> next(&amp;<span class="kwa">mut self</span>) -&gt; Option&lt;&amp;'a T&gt; {
        <span class="kwa">match</span> *<span class="kwa">self</span>.cur {
            List::Nil =&gt; None,
            List::Cons(<span class="kwa">ref</span> elt, next) =&gt; {
                <span class="kwa">self</span>.cur = next;
                Some(elt)
            }
        }
    }
}

<span class="slc">//</span>
<span class="slc">// preprocess</span>
<span class="slc">//</span>

<span class="slc">// Takes a pieces p on the form [(y1, x1), (y2, x2), ...] and returns</span>
<span class="slc">// every possible transformations (the 6 rotations with their</span>
<span class="slc">// corresponding mirrored piece), with, as minimum coordinates, (0,</span>
<span class="slc">// 0).  If all is false, only generate half of the possibilities (used</span>
<span class="slc">// to break the symmetry of the board).</span>
<span class="kwa">fn</span> transform(piece: Vec&lt;(i32, i32)&gt; , all: bool) -&gt; Vec&lt;Vec&lt;(i32, i32)&gt;&gt; {
    <span class="kwa">let mut</span> res: Vec&lt;Vec&lt;(i32, i32)&gt;&gt; =
        <span class="slc">// rotations</span>
        iterate(piece, |rot| rot.iter().map(|&amp;(y, x)| (x + y, -y)).collect())
        .take(<span class="kwa">if</span> all { <span class="num">6</span> } <span class="kwa">else</span> { <span class="num">3</span> })
        <span class="slc">// mirror</span>
        .flat_map(|cur_piece| {
            iterate(cur_piece, |mir| mir.iter().map(|&amp;(y, x)| (x, y)).collect())
            .take(<span class="num">2</span>)
        }).collect();

    <span class="slc">// translating to (0, 0) as minimum coordinates.</span>
    <span class="kwa">for</span> cur_piece <span class="kwa">in</span> res.iter_mut() {
        <span class="kwa">let</span> (dy, dx) = *cur_piece.iter().min().unwrap();
        <span class="kwa">for</span> &amp;<span class="kwa">mut</span> (<span class="kwa">ref mut</span> y, <span class="kwa">ref mut</span> x) <span class="kwa">in</span> cur_piece.iter_mut() {
            *y -= dy; *x -= dx;
        }
    }

    res
}

<span class="slc">// A mask is a piece somewhere on the board.  It is represented as a</span>
<span class="slc">// u64: for i in the first 50 bits, m[i] = 1 if the cell at (i/5, i%5)</span>
<span class="slc">// is occupied.  m[50 + id] = 1 if the identifier of the piece is id.</span>

<span class="slc">// Takes a piece with minimum coordinate (0, 0) (as generated by</span>
<span class="slc">// transform).  Returns the corresponding mask if p translated by (dy,</span>
<span class="slc">// dx) is on the board.</span>
<span class="kwa">fn</span> mask(dy: i32, dx: i32, id: usize, p: &amp;Vec&lt;(i32, i32)&gt;) -&gt; Option&lt;u64&gt; {
    <span class="kwa">let mut</span> m = <span class="num">1</span> &lt;&lt; (<span class="num">50</span> + id);
    <span class="kwa">for</span> &amp;(y, x) <span class="kwa">in</span> p.iter() {
        <span class="kwa">let</span> x = x + dx + (y + (dy % <span class="num">2</span>)) / <span class="num">2</span>;
        <span class="kwa">if</span> x &lt; <span class="num">0</span> || x &gt; <span class="num">4</span> { <span class="kwa">return</span> None; }
        <span class="kwa">let</span> y = y + dy;
        <span class="kwa">if</span> y &lt; <span class="num">0</span> || y &gt; <span class="num">9</span> { <span class="kwa">return</span> None; }
        m |= <span class="num">1</span> &lt;&lt; (y * <span class="num">5</span> + x) <span class="kwa">as</span> usize;
    }
    Some(m)
}

<span class="slc">// Makes every possible masks.  masks[i][id] correspond to every</span>
<span class="slc">// possible masks for piece with identifier id with minimum coordinate</span>
<span class="slc">// (i/5, i%5).</span>
<span class="kwa">fn</span> make_masks() -&gt; Vec&lt;Vec&lt;Vec&lt;u64&gt; &gt; &gt; {
    <span class="kwa">let</span> pieces = vec!(
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">0</span>,<span class="num">3</span>),(<span class="num">1</span>,<span class="num">3</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">0</span>,<span class="num">3</span>),(<span class="num">1</span>,<span class="num">0</span>),(<span class="num">1</span>,<span class="num">1</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">2</span>),(<span class="num">2</span>,<span class="num">1</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">1</span>),(<span class="num">2</span>,<span class="num">1</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">0</span>),(<span class="num">1</span>,<span class="num">1</span>),(<span class="num">2</span>,<span class="num">1</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">1</span>),(<span class="num">1</span>,<span class="num">2</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">1</span>,<span class="num">1</span>),(<span class="num">1</span>,<span class="num">2</span>),(<span class="num">2</span>,<span class="num">1</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">0</span>),(<span class="num">1</span>,<span class="num">2</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">2</span>),(<span class="num">1</span>,<span class="num">3</span>)),
        vec!((<span class="num">0</span>,<span class="num">0</span>),(<span class="num">0</span>,<span class="num">1</span>),(<span class="num">0</span>,<span class="num">2</span>),(<span class="num">0</span>,<span class="num">3</span>),(<span class="num">1</span>,<span class="num">2</span>)));

    <span class="slc">// To break the central symmetry of the problem, every</span>
    <span class="slc">// transformation must be taken except for one piece (piece 3</span>
    <span class="slc">// here).</span>
    <span class="kwa">let</span> transforms: Vec&lt;Vec&lt;Vec&lt;(i32, i32)&gt;&gt;&gt; =
        pieces.into_iter().enumerate()
        .map(|(id, p)| transform(p, id != <span class="num">3</span>))
        .collect();

    (<span class="num">0</span>.<span class="num">.50</span>).map(|yx| {
        transforms.iter().enumerate().map(|(id, t)| {
            t.iter().filter_map(|p| mask(yx / <span class="num">5</span>, yx % <span class="num">5</span>, id, p)).collect()
        }).collect()
    }).collect()
}

<span class="slc">// Check if all coordinates can be covered by an unused piece and that</span>
<span class="slc">// all unused piece can be placed on the board.</span>
<span class="kwa">fn</span> is_board_unfeasible(board: u64, masks: &amp;Vec&lt;Vec&lt;Vec&lt;u64&gt;&gt;&gt;) -&gt; bool {
    <span class="kwa">let mut</span> coverable = board;
    <span class="kwa">for</span> (i, masks_at) <span class="kwa">in</span> masks.iter().enumerate() {
        <span class="kwa">if</span> board &amp; <span class="num">1</span> &lt;&lt; i != <span class="num">0</span> { <span class="kwa">continue</span>; }
        <span class="kwa">for</span> (cur_id, pos_masks) <span class="kwa">in</span> masks_at.iter().enumerate() {
            <span class="kwa">if</span> board &amp; <span class="num">1</span> &lt;&lt; (<span class="num">50</span> + cur_id) != <span class="num">0</span> { <span class="kwa">continue</span>; }
            <span class="kwa">for</span> &amp;cur_m <span class="kwa">in</span> pos_masks.iter() {
                <span class="kwa">if</span> cur_m &amp; board != <span class="num">0</span> { <span class="kwa">continue</span>; }
                coverable |= cur_m;
                <span class="slc">// if every coordinates can be covered and every</span>
                <span class="slc">// piece can be used.</span>
                <span class="kwa">if</span> coverable == (<span class="num">1</span> &lt;&lt; <span class="num">60</span>) - <span class="num">1</span> { <span class="kwa">return false</span>; }
            }
        }
        <span class="kwa">if</span> coverable &amp; <span class="num">1</span> &lt;&lt; i == <span class="num">0</span> { <span class="kwa">return true</span>; }
    }
    <span class="kwa">true</span>
}

<span class="slc">// Filter the masks that we can prove to result to unfeasible board.</span>
<span class="kwa">fn</span> filter_masks(masks: &amp;<span class="kwa">mut</span> Vec&lt;Vec&lt;Vec&lt;u64&gt;&gt;&gt;) {
    <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span>..masks.len() {
        <span class="kwa">for</span> j <span class="kwa">in</span> <span class="num">0</span>..masks[i].len() {
            masks[i][j] =
                masks[i][j].iter().map(|&amp;m| m)
                .filter(|&amp;m| !is_board_unfeasible(m, masks))
                .collect();
        }
    }
}

<span class="slc">// Gets the identifier of a mask.</span>
<span class="kwa">fn</span> get_id(m: u64) -&gt; u8 {
    <span class="kwa">for</span> id <span class="kwa">in</span> <span class="num">0</span>.<span class="num">.10</span> {
        <span class="kwa">if</span> m &amp; (<span class="num">1</span> &lt;&lt; (id + <span class="num">50</span>) <span class="kwa">as</span> usize) != <span class="num">0</span> { <span class="kwa">return</span> id; }
    }
    panic!(<span class="str">&quot;{:016x} does not have a valid identifier&quot;</span>, m);
}

<span class="slc">// Converts a list of mask to a Vec&lt;u8&gt;.</span>
<span class="kwa">fn</span> to_vec(raw_sol: &amp;List&lt;u64&gt;) -&gt; Vec&lt;u8&gt; {
    <span class="kwa">let mut</span> sol = repeat('.' <span class="kwa">as</span> u8).take(<span class="num">50</span>).collect::&lt;Vec&lt;_&gt;&gt;();
    <span class="kwa">for</span> &amp;m <span class="kwa">in</span> raw_sol.iter() {
        <span class="kwa">let</span> id = '<span class="num">0</span>' <span class="kwa">as</span> u8 + get_id(m);
        <span class="kwa">for</span> i <span class="kwa">in</span> <span class="num">0</span>.<span class="num">.50</span> {
            <span class="kwa">if</span> m &amp; <span class="num">1</span> &lt;&lt; i != <span class="num">0</span> { sol[i] = id; }
        }
    }
    sol
}

<span class="slc">// Prints a solution in Vec&lt;u8&gt; form.</span>
<span class="kwa">fn</span> print_sol(sol: &amp;Vec&lt;u8&gt;) {
    <span class="kwa">for</span> (i, c) <span class="kwa">in</span> sol.iter().enumerate() {
        <span class="kwa">if</span> i % <span class="num">5</span> == <span class="num">0</span> { println!(<span class="str">&quot;&quot;</span>); }
        <span class="kwa">if</span> (i + <span class="num">5</span>) % <span class="num">10</span> == <span class="num">0</span> { print!(<span class="str">&quot; &quot;</span>); }
        print!(<span class="str">&quot;{} &quot;</span>, *c <span class="kwa">as</span> char);
    }
    println!(<span class="str">&quot;&quot;</span>);
}

<span class="slc">// The data managed during the search</span>
<span class="kwa">struct</span> Data {
    <span class="slc">// Number of solution found.</span>
    nb: i32,
    <span class="slc">// Lexicographically minimal solution found.</span>
    min: Vec&lt;u8&gt;,
    <span class="slc">// Lexicographically maximal solution found.</span>
    max: Vec&lt;u8&gt;
}
<span class="kwa">impl</span> Data {
    <span class="kwa">fn</span> new() -&gt; Data {
        Data { nb: <span class="num">0</span>, min: vec!(), max: vec!() }
    }
    <span class="kwa">fn</span> reduce_from(&amp;<span class="kwa">mut self</span>, other: Data) {
        <span class="kwa">self</span>.nb += other.nb;
        <span class="kwa">let</span> Data { min, max, ..} = other;
        <span class="kwa">if</span> min &lt; <span class="kwa">self</span>.min { <span class="kwa">self</span>.min = min; }
        <span class="kwa">if</span> max &gt; <span class="kwa">self</span>.max { <span class="kwa">self</span>.max = max; }
    }
}

<span class="slc">// Records a new found solution.  Returns false if the search must be</span>
<span class="slc">// stopped.</span>
<span class="kwa">fn</span> handle_sol(raw_sol: &amp;List&lt;u64&gt;, data: &amp;<span class="kwa">mut</span> Data) {
    <span class="slc">// because we break the symmetry, 2 solutions correspond to a call</span>
    <span class="slc">// to this method: the normal solution, and the same solution in</span>
    <span class="slc">// reverse order, i.e. the board rotated by half a turn.</span>
    data.nb += <span class="num">2</span>;
    <span class="kwa">let</span> sol1 = to_vec(raw_sol);
    <span class="kwa">let</span> sol2: Vec&lt;u8&gt; = sol1.iter().rev().map(|x| *x).collect();

    <span class="kwa">if</span> data.nb == <span class="num">2</span> {
        data.min = sol1.clone();
        data.max = sol1.clone();
    }

    <span class="kwa">if</span> sol1 &lt; data.min { data.min = sol1; }
    <span class="kwa">else if</span> sol1 &gt; data.max { data.max = sol1; }
    <span class="kwa">if</span> sol2 &lt; data.min { data.min = sol2; }
    <span class="kwa">else if</span> sol2 &gt; data.max { data.max = sol2; }
}

<span class="kwa">fn</span> search(
    masks: &amp;Vec&lt;Vec&lt;Vec&lt;u64&gt;&gt;&gt;,
    board: u64,
    <span class="kwa">mut</span> i: usize,
    cur: List&lt;u64&gt;,
    data: &amp;<span class="kwa">mut</span> Data)
{
    <span class="slc">// Search for the lesser empty coordinate.</span>
    <span class="kwa">while</span> board &amp; (<span class="num">1</span> &lt;&lt; i) != <span class="num">0</span> &amp;&amp; i &lt; <span class="num">50</span> { i += <span class="num">1</span>; }
    <span class="slc">// the board is full: a solution is found.</span>
    <span class="kwa">if</span> i &gt;= <span class="num">50</span> { <span class="kwa">return</span> handle_sol(&amp;cur, data); }
    <span class="kwa">let</span> masks_at = &amp;masks[i];

    <span class="slc">// for every unused piece</span>
    <span class="kwa">for</span> id <span class="kwa">in</span> (<span class="num">0</span>.<span class="num">.10</span>).filter(|&amp;id| board &amp; (<span class="num">1</span> &lt;&lt; (id + <span class="num">50</span>)) == <span class="num">0</span>) {
        <span class="slc">// for each mask that fits on the board</span>
        <span class="kwa">for</span> m <span class="kwa">in</span> masks_at[id].iter().filter(|&amp;m| board &amp; *m == <span class="num">0</span>) {
            <span class="slc">// This check is too costly.</span>
            <span class="slc">//if is_board_unfeasible(board | m, masks) {continue;}</span>
            search(masks, board | *m, i + <span class="num">1</span>, List::Cons(*m, &amp;cur), data);
        }
    }
}

<span class="kwa">fn</span> par_search(masks: Vec&lt;Vec&lt;Vec&lt;u64&gt;&gt;&gt;) -&gt; Data {
    <span class="kwa">let</span> masks = Arc::new(masks);
    <span class="kwa">let</span> (tx, rx) = channel();

    <span class="slc">// launching the search in parallel on every masks at minimum</span>
    <span class="slc">// coordinate (0,0)</span>
    <span class="kwa">for</span> &amp;m <span class="kwa">in</span> masks[<span class="num">0</span>].iter().flat_map(|masks_pos| masks_pos.iter()) {
        <span class="kwa">let</span> masks = masks.clone();
        <span class="kwa">let</span> tx = tx.clone();
        spawn(<span class="kwa">move</span>|| {
            <span class="kwa">let mut</span> data = Data::new();
            search(&amp;masks, m, <span class="num">1</span>, List::Cons(m, &amp;List::Nil), &amp;<span class="kwa">mut</span> data);
            tx.send(data).unwrap();
        });
    }

    <span class="slc">// collecting the results</span>
    drop(tx);
    <span class="kwa">let mut</span> data = rx.recv().unwrap();
    <span class="kwa">for</span> d <span class="kwa">in</span> rx.iter() { data.reduce_from(d); }
    data
}

<span class="kwa">fn</span> main () {
    <span class="kwa">let mut</span> masks = make_masks();
    filter_masks(&amp;<span class="kwa">mut</span> masks);
    <span class="kwa">let</span> data = par_search(masks);
    println!(<span class="str">&quot;{} solutions found&quot;</span>, data.nb);
    print_sol(&amp;data.min);
    print_sol(&amp;data.max);
    println!(<span class="str">&quot;&quot;</span>);
}
