
Fri, 04 Sep 2015 21:07:35 GMT

MAKE:
cp: ‘knucleotide.sbcl-2.sbcl’ and ‘./knucleotide.sbcl-2.sbcl’ are the same file
SBCL built with: /usr/local/bin/sbcl --userinit /dev/null --batch --eval '(load "knucleotide.sbcl-2.sbcl_compile")'
### START knucleotide.sbcl-2.sbcl_compile
(handler-bind ((sb-ext:defconstant-uneql      (lambda (c) (abort c))))      (load (compile-file "knucleotide.sbcl-2.sbcl" ))) (save-lisp-and-die "sbcl.core" :purify t)
### END knucleotide.sbcl-2.sbcl_compile

; compiling file "/home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl" (written 24 JAN 2013 02:01:15 PM):
; compiling (DEFUN SLICE-AND-DICE ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl
; in: DEFUN SLICE-AND-DICE
;     (EXPT 4 K)
; --> LET 
; ==>
;   (ASH 1 (* (ABS SB-C::POWER) 2))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The second argument is a (MOD 1073741825), not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline ASH (cost 3) because:
;       The second argument is a (MOD 1073741825), not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

;     (1- (EXPT 4 K))
; ==>
;   (- (EXPT 4 K) 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (RATIONAL 0), not a FIXNUM.
;       The result is a (VALUES (RATIONAL -1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (RATIONAL 0), not a FIXNUM.
;       The result is a (VALUES (RATIONAL -1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       etc.

;     (LOGAND MASK (LETTER-TO-NUM GENE I GENE-NUM))
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -1), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 3) because:
;       The first argument is a (INTEGER -1), not a (UNSIGNED-BYTE 32).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (EXPT 4 K)
; --> LET 
; ==>
;   (ASH 1 (* (ABS SB-C::POWER) 2))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DECLAIM (INLINE LETTER-TO-NUM))
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl
; in: DECLAIM (INLINE LETTER-TO-NUM)
;     (DECLAIM (INLINE LETTER-TO-NUM))
; --> EVAL-WHEN 
; ==>
;   (SB-C::%PROCLAIM '(INLINE LETTER-TO-NUM) (SB-C:SOURCE-LOCATION))
; 
; caught STYLE-WARNING:
;   Proclaiming COMMON-LISP-USER::LETTER-TO-NUM to be INLINE, but 1 call to it was
;   previously compiled. A declaration of NOTINLINE at the call site will eliminate
;   this warning, as will proclaiming and defining the function before its first
;   potential use.

; compiling (DEFUN LETTER-TO-NUM ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl
; in: DEFUN LETTER-TO-NUM
;     (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (LOGXOR (ASH IDX 2) 3)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (LOGXOR (ASH IDX 2) 2)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (LOGXOR (ASH IDX 2) 1)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

;     (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; compiling (DECLAIM (INLINE GENE-TO-NUM))
; compiling (DEFUN GENE-TO-NUM ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl
; in: DEFUN GENE-TO-NUM
;     (LETTER-TO-NUM GENE I GENE-NUM)
; --> BLOCK ECASE LET COND IF COND IF COND IF COND IF PROGN LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF COND IF COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 3)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF COND IF COND IF PROGN LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 2)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF COND IF PROGN LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 1)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK ECASE LET COND IF PROGN 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; compiling (DECLAIM (INLINE NUM-TO-GENE))
; compiling (DEFUN NUM-TO-GENE ...)
; compiling (DEFUN DISCARD-DATA-HEADER ...)
; compiling (DEFUN READ-DATA ...)
; compiling (DEFUN PRINT-PRECENTAGES ...)
; compiling (DEFUN PRINT-OCCURENCE ...)
; file: /home/dunham/benchmarksgame/bench/knucleotide/knucleotide.sbcl-2.sbcl
; in: DEFUN PRINT-OCCURENCE
;     (GENE-TO-NUM SLICE)
; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 3)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF COND IF PROGN LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 2)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF PROGN LOGXOR 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF COND IF PROGN 
; ==>
;   (LOGXOR (ASH IDX 2) 1)
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; --> BLOCK LET DOTIMES DO BLOCK LET TAGBODY TAGBODY SETF SETQ THE 
; --> LETTER-TO-NUM BLOCK ECASE LET COND IF PROGN 
; ==>
;   (ASH IDX 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; compiling (DEFUN MAIN ...)
; compiling (DEFUN TEST ...); 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
;   printed 25 notes


; /home/dunham/benchmarksgame_onecore/knucleotide/tmp/knucleotide.sbcl-2.fasl written
; compilation finished in 0:00:00.077
[undoing binding stack and other enclosing state... done]
[saving current Lisp image into sbcl.core:
writing 3600 bytes from the read-only space at 0x1000000
writing 2272 bytes from the static space at 0x1100000
writing 30330880 bytes from the dynamic space at 0x9000000
done]
### START knucleotide.sbcl-2.sbcl_run
(main) (quit)
### END knucleotide.sbcl-2.sbcl_run

0.72s to complete and log all make actions

COMMAND LINE:
/usr/local/bin/sbcl   --noinform --core sbcl.core --userinit /dev/null --load knucleotide.sbcl-2.sbcl_run 0 < knucleotide-input25000000.txt

PROGRAM OUTPUT:
A 30.295
T 30.151
C 19.800
G 19.754

AA 9.177
TA 9.132
AT 9.131
TT 9.091
CA 6.002
AC 6.001
AG 5.987
GA 5.984
CT 5.971
TC 5.971
GT 5.957
TG 5.956
CC 3.917
GC 3.911
CG 3.909
GG 3.902

1471758	GGT
446535	GGTA
47336	GGTATT
893	GGTATTTTAATT
893	GGTATTTTAATTTATAGT
